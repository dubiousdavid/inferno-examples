{"version":3,"sources":["node_modules/inferno/dist/inferno.min.js","node_modules/path-parser/dist/commonjs/path-parser.js","node_modules/process/browser.js","node_modules/route-node/dist/commonjs/route-node.js","node_modules/router5.transition-path/index.js","node_modules/router5/constants.js","node_modules/router5/core/clone.js","node_modules/router5/core/middleware.js","node_modules/router5/core/navigation.js","node_modules/router5/core/plugins.js","node_modules/router5/core/route-lifecycle.js","node_modules/router5/core/router-lifecycle.js","node_modules/router5/core/utils.js","node_modules/router5/create-router.js","node_modules/router5/index.js","node_modules/router5/plugins/browser/browser.js","node_modules/router5/plugins/browser/index.js","node_modules/router5/plugins/browser/utils.js","node_modules/router5/plugins/listeners/index.js","node_modules/router5/plugins/logger/index.js","node_modules/router5/transition/index.js","node_modules/router5/transition/resolve.js","node_modules/rxjs/BehaviorSubject.js","node_modules/rxjs/InnerSubscriber.js","node_modules/rxjs/Observable.js","node_modules/rxjs/Observer.js","node_modules/rxjs/OuterSubscriber.js","node_modules/rxjs/Subject.js","node_modules/rxjs/SubjectSubscription.js","node_modules/rxjs/Subscriber.js","node_modules/rxjs/Subscription.js","node_modules/rxjs/add/operator/do.js","node_modules/rxjs/add/operator/map.js","node_modules/rxjs/add/operator/publishBehavior.js","node_modules/rxjs/add/operator/scan.js","node_modules/rxjs/add/operator/startWith.js","node_modules/rxjs/add/operator/switchMap.js","node_modules/rxjs/observable/ArrayObservable.js","node_modules/rxjs/observable/ConnectableObservable.js","node_modules/rxjs/observable/EmptyObservable.js","node_modules/rxjs/observable/ScalarObservable.js","node_modules/rxjs/operator/concat.js","node_modules/rxjs/operator/do.js","node_modules/rxjs/operator/map.js","node_modules/rxjs/operator/mergeAll.js","node_modules/rxjs/operator/multicast.js","node_modules/rxjs/operator/publishBehavior.js","node_modules/rxjs/operator/scan.js","node_modules/rxjs/operator/startWith.js","node_modules/rxjs/operator/switchMap.js","node_modules/rxjs/symbol/iterator.js","node_modules/rxjs/symbol/observable.js","node_modules/rxjs/symbol/rxSubscriber.js","node_modules/rxjs/util/ObjectUnsubscribedError.js","node_modules/rxjs/util/UnsubscriptionError.js","node_modules/rxjs/util/errorObject.js","node_modules/rxjs/util/isArray.js","node_modules/rxjs/util/isArrayLike.js","node_modules/rxjs/util/isFunction.js","node_modules/rxjs/util/isObject.js","node_modules/rxjs/util/isPromise.js","node_modules/rxjs/util/isScheduler.js","node_modules/rxjs/util/root.js","node_modules/rxjs/util/subscribeToResult.js","node_modules/rxjs/util/toSubscriber.js","node_modules/rxjs/util/tryCatch.js","node_modules/search-params/index.js","node_modules/auto-reload-brunch/vendor/auto-reload.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/vendor.js","sourcesContent":["\nrequire.register(\"inferno/dist/inferno.min.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"inferno\");\n  (function() {\n    !(function(e,n){\"object\"==typeof exports&&\"undefined\"!=typeof module?n(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],n):n(e.Inferno=e.Inferno||{})})(this,(function(e){\"use strict\";function n(e){return!c(e.prototype)&&!c(e.prototype.render)}function t(e){var n=typeof e;return\"string\"===n||\"number\"===n}function r(e){return c(e)||f(e)}function o(e){return f(e)||e===!1||d(e)||c(e)}function i(e){return\"function\"==typeof e}function l(e){return\"o\"===e[0]&&\"n\"===e[1]}function a(e){return\"string\"==typeof e}function u(e){return\"number\"==typeof e}function f(e){return null===e}function d(e){return e===!0}function c(e){return void 0===e}function s(e){return\"object\"==typeof e}function v(e){throw e||(e=mn),new Error(\"Inferno Error: \"+e)}function p(e,n){var t,r={};if(e)for(t in e)r[t]=e[t];if(n)for(t in n)r[t]=n[t];return r}function m(){this.listeners=[]}function h(e,n){return n.key=e,n}function g(e,n){return u(e)&&(e=\".\"+e),f(n.key)||\".\"===n.key[0]?h(e,n):n}function y(e,n){return n.key=e+n.key,n}function k(e,n,r,i){for(var l=e.length;r<l;r++){var a=e[r],u=i+\".\"+r;o(a)||(gn(a)?k(a,n,0,u):(t(a)?a=cn(a,null):(sn(a)&&a.dom||a.key&&\".\"===a.key[0])&&(a=un(a)),a=f(a.key)||\".\"===a.key[0]?h(u,a):y(i,a),n.push(a)))}}function b(e){var n;e.$?e=e.slice():e.$=!0;for(var r=0,i=e.length;r<i;r++){var l=e[r];if(o(l)||gn(l)){var a=(n||e).slice(0,r);return k(e,a,r,\"\"),a}t(l)?(n||(n=e.slice(0,r)),n.push(g(r,cn(l,null)))):sn(l)&&l.dom||f(l.key)&&!(64&l.flags)?(n||(n=e.slice(0,r)),n.push(g(r,un(l)))):n&&n.push(g(r,un(l)))}return n||e}function C(e){return gn(e)?b(e):sn(e)&&e.dom?un(e):e}function N(e,n,t){28&e.flags||!r(t)||r(n.children)||(e.children=n.children),n.ref&&(e.ref=n.ref,delete n.ref),n.events&&(e.events=n.events),r(n.key)||(e.key=n.key,delete n.key)}function x(e,n){n.flags=\"svg\"===e?128:\"input\"===e?512:\"select\"===e?2048:\"textarea\"===e?1024:\"media\"===e?256:2}function w(e){var n=e.props,t=e.children;if(28&e.flags){var i=e.type,l=i.defaultProps;if(!r(l))if(n)for(var u in l)c(n[u])&&(n[u]=l[u]);else n=e.props=l;a(i)&&(x(i,e),n&&n.children&&(e.children=n.children,t=n.children))}n&&N(e,n,t),o(t)||(e.children=C(t)),n&&!o(n.children)&&(n.children=C(n.children))}function _(e,n,t,r){var o=En.get(e);t?(o||(o={items:new Map,count:0,docEvent:null},o.docEvent=S(e,o),En.set(e,o)),n||(o.count++,Sn&&\"onClick\"===e&&U(r)),o.items.set(r,t)):o&&o.items.has(r)&&(o.count--,o.items.delete(r),0===o.count&&(document.removeEventListener(O(e),o.docEvent),En.delete(e)))}function M(e,n,t,r,o){var i=t.get(n);if((!i||(r--,o.dom=n,i.event?i.event(i.data,e):i(e),!o.stopPropagation))&&r>0){var l=n.parentNode;(l&&l.disabled!==!0||l===document.body)&&M(e,l,t,r,o)}}function O(e){return e.substr(2).toLowerCase()}function S(e,n){var t=function(e){var t={stopPropagation:!1,dom:document};Object.defineProperty(e,\"currentTarget\",{configurable:!0,get:function(){return t.dom}}),e.stopPropagation=function(){t.stopPropagation=!0};var r=n.count;r>0&&M(e,e.target,n.items,r,t)};return document.addEventListener(O(e),t),t}function E(){}function U(e){e.onclick=E}function V(e){return\"checkbox\"===e||\"radio\"===e}function D(e){return V(e.type)?!r(e.checked):!r(e.value)}function I(e){var n=this.vNode,t=n.events||jn,r=n.dom;if(t.onInput){var o=t.onInput;o.event?o.event(o.data,e):o(e)}else t.oninput&&t.oninput(e);L(this.vNode,r)}function T(e){var n=this.vNode,t=n.events||jn,r=t.onChange;r.event?r.event(r.data,e):r(e)}function P(e){var n=this.vNode,t=n.events||jn,r=n.dom;if(t.onClick){var o=t.onClick;o.event?o.event(o.data,e):o(e)}else t.onclick&&t.onclick(e);L(this.vNode,r)}function j(e){var n=document.querySelectorAll('input[type=\"radio\"][name=\"'+e+'\"]');[].forEach.call(n,(function(e){var n=Un.get(e);if(n){n.vNode.props&&(e.checked=n.vNode.props.checked)}}))}function W(e,n){var t=e.props||jn;if(L(e,n),D(t)){var r=Un.get(n);return r||(r={vNode:e},V(t.type)?(n.onclick=P.bind(r),n.onclick.wrapped=!0):(n.oninput=I.bind(r),n.oninput.wrapped=!0),t.onChange&&(n.onchange=T.bind(r),n.onchange.wrapped=!0),Un.set(n,r)),r.vNode=e,!0}return!1}function L(e,n){var t=e.props||jn,o=t.type,i=t.value,l=t.checked,a=t.multiple,u=t.defaultValue,f=!r(i);o&&o!==n.type&&(n.type=o),a&&a!==n.multiple&&(n.multiple=a),r(u)||f||(n.defaultValue=u+\"\"),V(o)?(f&&(n.value=i),r(l)||(n.checked=l),\"radio\"===o&&t.name&&j(t.name)):f&&n.value!==i?n.value=i:r(l)||(n.checked=l)}function A(e){return!r(e.value)}function z(e,n){if(\"optgroup\"===e.type){var t=e.children;if(gn(t))for(var r=0,o=t.length;r<o;r++)R(t[r],n);else sn(t)&&R(t,n)}else R(e,n)}function R(e,n){var t=e.props||jn,o=e.dom;o.value=t.value,gn(n)&&n.indexOf(t.value)!==-1||t.value===n?o.selected=!0:r(n)&&r(t.selected)||(o.selected=t.selected||!1)}function K(e){var n=this.vNode,t=n.events||jn,r=n.dom;if(t.onChange){var o=t.onChange;o.event?o.event(o.data,e):o(e)}else t.onchange&&t.onchange(e);F(this.vNode,r,!1)}function G(e,n,t){var r=e.props||jn;if(F(e,n,t),A(r)){var o=Un.get(n);return o||(o={vNode:e},n.onchange=K.bind(o),n.onchange.wrapped=!0,Un.set(n,o)),o.vNode=e,!0}return!1}function F(e,n,t){var i=e.props||jn;i.multiple!==n.multiple&&(n.multiple=i.multiple);var l=e.children;if(!o(l)){var a=i.value;if(t&&r(a)&&(a=i.defaultValue),gn(l))for(var u=0,f=l.length;u<f;u++)z(l[u],a);else sn(l)&&z(l,a)}}function B(e){return!r(e.value)}function H(e){var n=this.vNode,t=n.events||jn,r=t.onChange;r.event?r.event(r.data,e):r(e)}function $(e){var n=this.vNode,t=n.events||jn,r=n.dom;if(t.onInput){var o=t.onInput;o.event?o.event(o.data,e):o(e)}else t.oninput&&t.oninput(e);J(this.vNode,r,!1)}function q(e,n,t){var r=e.props||jn;J(e,n,t);var o=Un.get(n);return!!B(r)&&(o||(o={vNode:e},n.oninput=$.bind(o),n.oninput.wrapped=!0,r.onChange&&(n.onchange=H.bind(o),n.onchange.wrapped=!0),Un.set(n,o)),o.vNode=e,!0)}function J(e,n,t){var o=e.props||jn,i=o.value,l=n.value;if(r(i)){if(t){var a=o.defaultValue;r(a)?\"\"!==l&&(n.value=\"\"):a!==l&&(n.value=a)}}else l!==i&&(n.value=i)}function Y(e,n,t,r){return 512&e?W(n,t):2048&e?G(n,t,r):!!(1024&e)&&q(n,t,r)}function X(e){for(var n=e.firstChild;n;)if(8===n.nodeType)if(\"!\"===n.data){var t=document.createTextNode(\"\");e.replaceChild(t,n),n=n.nextSibling}else{var r=n.previousSibling;e.removeChild(n),n=r||e.firstChild}else n=n.nextSibling}function Q(e,n,t,r,o,i){var l=e.type,a=e.ref;e.dom=n;var u=e.props||jn;if(i){var f=n.namespaceURI===Cn,d=Be(e,l,u,r,f),c=d._lastInput;d._vComponent=e,d._vNode=e,re(c,n,t,d._childContext,f),Ke(e,a,d,t),yn.findDOMNodeEnabled&&Tn.set(d,n),e.children=d}else{var s=qe(e,l,u,r);re(s,n,t,r,o),e.children=s,e.dom=s.dom,Ge(a,n,t)}return n}function Z(e,n,t,r,o){var i=e.children,l=e.props,a=e.events,u=e.flags,f=e.ref;if((o||128&u)&&(o=!0),1!==n.nodeType||n.tagName.toLowerCase()!==e.type){var d=Ae(e,null,t,r,o);return e.dom=d,nn(n.parentNode,d,n),d}e.dom=n,i&&ee(i,n,t,r,o);var c=!1;if(2&u||(c=Y(u,e,n,!1)),l)for(var s in l)Ve(s,null,l[s],n,o,c);if(a)for(var v in a)Ie(v,null,a[v],n);return f&&Fe(n,f,t),n}function ee(e,n,r,o,i){X(n);var l=n.firstChild;if(gn(e))for(var a=0,u=e.length;a<u;a++){var d=e[a];!f(d)&&s(d)&&(l?(l=re(d,l,r,o,i),l=l.nextSibling):je(d,n,r,o,i))}else t(e)?(l&&3===l.nodeType?l.nodeValue!==e&&(l.nodeValue=e):e&&(n.textContent=e),l=l.nextSibling):s(e)&&(re(e,l,r,o,i),l=l.nextSibling);for(;l;){var c=l.nextSibling;n.removeChild(l),l=c}}function ne(e,n){if(3!==n.nodeType){var t=We(e,null);return e.dom=t,nn(n.parentNode,t,n),t}var r=e.children;return n.nodeValue!==r&&(n.nodeValue=r),e.dom=n,n}function te(e,n){return e.dom=n,n}function re(e,n,t,r,o){var i=e.flags;return 28&i?Q(e,n,t,r,o,4&i):3970&i?Z(e,n,t,r,o):1&i?ne(e,n):4096&i?te(e,n):void v()}function oe(e,n,t){var r=n&&n.firstChild;if(r){for(re(e,r,t,jn,!1),r=n.firstChild;r=r.nextSibling;)n.removeChild(r);return!0}return!1}function ie(e,n,t,r){var o=e.type,i=Dn.get(o);if(!c(i)){var l=e.key,a=null===l?i.nonKeyed:i.keyed.get(l);if(!c(a)){var u=a.pop();if(!c(u))return xe(u,e,null,n,t,r,!0),e.dom}}return null}function le(e){var n=e.type,t=e.key,r=Dn.get(n);if(c(r)&&(r={nonKeyed:[],keyed:new Map},Dn.set(n,r)),f(t))r.nonKeyed.push(e);else{var o=r.keyed.get(t);c(o)&&(o=[],r.keyed.set(t,o)),o.push(e)}}function ae(e,n,t,r){var o=e.type,i=Vn.get(o);if(!c(i)){var l=e.key,a=null===l?i.nonKeyed:i.keyed.get(l);if(!c(a)){var u=a.pop();if(!c(u)){if(!_e(u,e,null,n,t,r,4&e.flags,!0))return e.dom}}}return null}function ue(e){var n=e.ref;if(!n||!(n.onComponentWillMount||n.onComponentWillUnmount||n.onComponentDidMount||n.onComponentWillUpdate||n.onComponentDidUpdate)){var t=e.type,r=e.key,o=Vn.get(t);if(c(o)&&(o={nonKeyed:[],keyed:new Map},Vn.set(t,o)),f(r))o.nonKeyed.push(e);else{var i=o.keyed.get(r);c(i)&&(i=[],o.keyed.set(r,i)),i.push(e)}}}function fe(e,n,t,r,o){var i=e.flags;28&i?ce(e,n,t,r,o):3970&i?se(e,n,t,r,o):4097&i&&de(e,n)}function de(e,n){n&&tn(n,e.dom)}function ce(e,n,t,o,i){var l=e.children,a=e.flags,u=4&a,f=e.ref,d=e.dom;if(i||(u?l._unmounted||(l._ignoreSetState=!0,yn.beforeUnmount&&yn.beforeUnmount(e),l.componentWillUnmount&&l.componentWillUnmount(),f&&!i&&f(null),l._unmounted=!0,yn.findDOMNodeEnabled&&Tn.delete(l),fe(l._lastInput,null,l._lifecycle,!1,i)):(r(f)||r(f.onComponentWillUnmount)||f.onComponentWillUnmount(d),fe(l,null,t,!1,i))),n){var c=l._lastInput;r(c)&&(c=l),tn(n,d)}yn.recyclingEnabled&&!u&&(n||o)&&ue(e)}function se(e,n,t,o,i){var l=e.dom,a=e.ref,u=e.events;a&&!i&&pe(a);var d=e.children;if(r(d)||ve(d,t,i),!f(u))for(var c in u)Ie(c,u[c],null,l),u[c]=null;n&&tn(n,l),yn.recyclingEnabled&&(n||o)&&le(e)}function ve(e,n,t){if(gn(e))for(var r=0,i=e.length;r<i;r++){var l=e[r];!o(l)&&s(l)&&fe(l,null,n,!1,t)}else s(e)&&fe(e,null,n,!1,t)}function pe(e){if(i(e))e(null);else{if(o(e))return;v()}}function me(e){yn.findDOMNodeEnabled||v();var n=e&&e.nodeType?e:null;return Tn.get(e)||n}function he(e){for(var n=0,t=In.length;n<t;n++){var r=In[n];if(r.dom===e)return r}return null}function ge(e,n,t){var r={dom:e,input:n,lifecycle:t};return In.push(r),r}function ye(e){for(var n=0,t=In.length;n<t;n++)if(In[n]===e)return void In.splice(n,1)}function ke(e,n){if(Pn===n&&v(),e!==pn){var t=he(n);if(f(t)){var i=new m;o(e)||(e.dom&&(e=un(e)),oe(e,n,i)||je(e,n,i,jn,!1),t=ge(n,e,i),i.trigger())}else{var l=t.lifecycle;l.listeners=[],r(e)?(fe(t.input,n,l,!1,!1),ye(t)):(e.dom&&(e=un(e)),Ce(t.input,e,n,l,jn,!1,!1)),l.trigger(),t.input=e}if(t){var a=t.input;if(a&&28&a.flags)return a.children}}}function be(e){return function(n,t){e||(e=n),ke(t,e)}}function Ce(e,n,t,r,o,i,l){if(e!==n){var a=e.flags,u=n.flags;28&u?28&a?_e(e,n,t,r,o,i,4&u,l):$e(t,Re(n,null,r,o,i,4&u),e,r,l):3970&u?3970&a?xe(e,n,t,r,o,i,l):$e(t,Ae(n,null,r,o,i),e,r,l):1&u?1&a?Me(e,n):$e(t,We(n,null),e,r,l):4096&u?4096&a?Oe(e,n):$e(t,Le(n,null),e,r,l):He(e,n,t,r,o,i,l)}}function Ne(e,n,t,r){sn(e)?fe(e,n,t,!0,r):gn(e)?rn(n,e,t,r):n.textContent=\"\"}function xe(e,n,t,o,i,l,a){var u=n.type;if(e.type!==u)en(e,n,t,o,i,l,a);else{var f=e.dom,d=e.props,c=n.props,s=e.children,v=n.children,p=e.flags,m=n.flags,h=n.ref,g=e.events,y=n.events;n.dom=f,(l||128&m)&&(l=!0),s!==v&&we(p,m,s,v,f,o,i,l,a);var k=!1;if(2&m||(k=Y(m,n,f,!1)),d!==c){var b=d||jn,C=c||jn;if(C!==jn)for(var N in C){var x=C[N],w=b[N];r(x)?Pe(N,x,f):Ve(N,w,x,f,l,k)}if(b!==jn)for(var _ in b)r(C[_])&&Pe(_,b[_],f)}g!==y&&De(g,y,f),h&&(e.ref!==h||a)&&Fe(f,h,o)}}function we(e,n,r,i,l,a,u,f,d){var c=!1,s=!1;64&n?c=!0:32&e&&32&n?(s=!0,c=!0):o(i)?Ne(r,l,a,d):o(r)?t(i)?Je(l,i):gn(i)?ze(i,l,a,u,f):je(i,l,a,u,f):t(i)?t(r)?Ye(l,i):(Ne(r,l,a,d),Je(l,i)):gn(i)?gn(r)?(c=!0,ln(r,i)&&(s=!0)):(Ne(r,l,a,d),ze(i,l,a,u,f)):gn(r)?(rn(l,r,a,d),je(i,l,a,u,f)):sn(i)&&(sn(r)?Ce(r,i,l,a,u,f,d):(Ne(r,l,a,d),je(i,l,a,u,f))),c&&(s?Ee(r,i,l,a,u,f,d):Se(r,i,l,a,u,f,d))}function _e(e,n,i,l,a,u,d,m){var h=e.type,g=n.type,y=e.key,k=n.key;if(h!==g||y!==k)return en(e,n,i,l,a,u,m),!1;var b=n.props||jn;if(d){var C=e.children;if(C._unmounted){if(f(i))return!0;nn(i,Re(n,null,l,a,u,4&n.flags),e.dom)}else{var N,x=C.state,w=C.state,_=C.props;c(C.getChildContext)||(N=C.getChildContext()),n.children=C,C._isSVG=u,C._syncSetState=!1,N=r(N)?a:p(a,N);var M=C._lastInput,O=C._updateComponent(x,w,_,b,a,!1,!1),S=!0;C._childContext=N,o(O)?O=dn():O===pn?(O=M,S=!1):t(O)?O=cn(O,null):gn(O)?v():s(O)&&O.dom&&(O=un(O)),28&O.flags?O.parentVNode=n:28&M.flags&&(M.parentVNode=n),C._lastInput=O,C._vNode=n,S&&(Ce(M,O,i,l,N,u,m),c(C.componentDidUpdate)||C.componentDidUpdate(_,x),yn.afterUpdate&&yn.afterUpdate(n),yn.findDOMNodeEnabled&&Tn.set(C,O.dom)),C._syncSetState=!0,n.dom=O.dom}}else{var E=!0,U=e.props,V=n.ref,D=!r(V),I=e.children,T=I;n.dom=e.dom,n.children=I,y!==k?E=!0:D&&!r(V.onComponentShouldUpdate)&&(E=V.onComponentShouldUpdate(U,b)),E!==!1&&(D&&!r(V.onComponentWillUpdate)&&V.onComponentWillUpdate(U,b),T=g(b,a),o(T)?T=dn():t(T)&&T!==pn?T=cn(T,null):gn(T)?v():s(T)&&T.dom&&(T=un(T)),T!==pn&&(Ce(I,T,i,l,a,u,m),n.children=T,D&&!r(V.onComponentDidUpdate)&&V.onComponentDidUpdate(U,b),n.dom=T.dom)),28&T.flags?T.parentVNode=n:28&I.flags&&(I.parentVNode=n)}return!1}function Me(e,n){var t=n.children,r=e.dom;n.dom=r,e.children!==t&&(r.nodeValue=t)}function Oe(e,n){n.dom=e.dom}function Se(e,n,t,r,o,i,l){for(var a=e.length,u=n.length,f=a>u?u:a,d=0;d<f;d++){var c=n[d];c.dom&&(c=n[d]=un(c)),Ce(e[d],c,t,r,o,i,l)}if(a<u)for(d=f;d<u;d++){var s=n[d];s.dom&&(s=n[d]=un(s)),Xe(t,je(s,null,r,o,i))}else if(0===u)rn(t,e,r,l);else if(a>u)for(d=f;d<a;d++)fe(e[d],t,r,!1,l)}function Ee(e,n,t,r,o,i,l){var a,u,d,s,v,p,m,h=e.length,g=n.length,y=h-1,k=g-1,b=0,C=0;if(0===h)return void(0!==g&&ze(n,t,r,o,i));if(0===g)return void rn(t,e,r,l);var N=e[b],x=n[C],w=e[y],_=n[k];x.dom&&(n[C]=x=un(x)),_.dom&&(n[k]=_=un(_));e:for(;;){for(;N.key===x.key;){if(Ce(N,x,t,r,o,i,l),b++,C++,b>y||C>k)break e;N=e[b],x=n[C],x.dom&&(n[C]=x=un(x))}for(;w.key===_.key;){if(Ce(w,_,t,r,o,i,l),y--,k--,b>y||C>k)break e;w=e[y],_=n[k],_.dom&&(n[k]=_=un(_))}if(w.key!==x.key){if(N.key!==_.key)break;Ce(N,_,t,r,o,i,l),p=k+1,v=p<n.length?n[p].dom:null,Qe(t,_.dom,v),b++,k--,N=e[b],_=n[k],_.dom&&(n[k]=_=un(_))}else Ce(w,x,t,r,o,i,l),Qe(t,x.dom,N.dom),y--,C++,w=e[y],x=n[C],x.dom&&(n[C]=x=un(x))}if(b>y){if(C<=k)for(p=k+1,v=p<n.length?n[p].dom:null;C<=k;)m=n[C],m.dom&&(n[C]=m=un(m)),C++,Qe(t,je(m,null,r,o,i),v)}else if(C>k)for(;b<=y;)fe(e[b++],t,r,!1,l);else{h=y-b+1,g=k-C+1;var M=new Array(g);for(a=0;a<g;a++)M[a]=-1;var O=!1,S=0,E=0;if(g<=4||h*g<=16){for(a=b;a<=y;a++)if(d=e[a],E<g)for(u=C;u<=k;u++)if(s=n[u],d.key===s.key){M[u-C]=a,S>u?O=!0:S=u,s.dom&&(n[u]=s=un(s)),Ce(d,s,t,r,o,i,l),E++,e[a]=null;break}}else{var U=new Map;for(a=C;a<=k;a++)U.set(n[a].key,a);for(a=b;a<=y;a++)d=e[a],E<g&&(u=U.get(d.key),c(u)||(s=n[u],M[u-C]=a,S>u?O=!0:S=u,s.dom&&(n[u]=s=un(s)),Ce(d,s,t,r,o,i,l),E++,e[a]=null))}if(h===e.length&&0===E)for(rn(t,e,r,l);C<g;)m=n[C],m.dom&&(n[C]=m=un(m)),C++,Qe(t,je(m,null,r,o,i),null);else{for(a=h-E;a>0;)d=e[b++],f(d)||(fe(d,t,r,!0,l),a--);if(O){var V=Ue(M);for(u=V.length-1,a=g-1;a>=0;a--)M[a]===-1?(S=a+C,m=n[S],m.dom&&(n[S]=m=un(m)),p=S+1,v=p<n.length?n[p].dom:null,Qe(t,je(m,t,r,o,i),v)):u<0||a!==V[u]?(S=a+C,m=n[S],p=S+1,v=p<n.length?n[p].dom:null,Qe(t,m.dom,v)):u--}else if(E!==g)for(a=g-1;a>=0;a--)M[a]===-1&&(S=a+C,m=n[S],m.dom&&(n[S]=m=un(m)),p=S+1,v=p<n.length?n[p].dom:null,Qe(t,je(m,null,r,o,i),v))}}}function Ue(e){var n,t,r,o,i,l=e.slice(0),a=[0],u=e.length;for(n=0;n<u;n++){var f=e[n];if(f!==-1)if(t=a[a.length-1],e[t]<f)l[n]=t,a.push(n);else{for(r=0,o=a.length-1;r<o;)i=(r+o)/2|0,e[a[i]]<f?r=i+1:o=i;f<e[a[r]]&&(r>0&&(l[n]=a[r-1]),a[r]=n)}}for(r=a.length,o=a[r-1];r-- >0;)a[r]=o,o=l[o];return a}function Ve(e,n,t,o,i,a){if(!(e in Mn||a&&\"value\"===e))if(e in xn)e=\"autoFocus\"===e?e.toLowerCase():e,o[e]=!!t;else if(e in Nn){var u=r(t)?\"\":t;o[e]!==u&&(o[e]=u)}else if(n!==t)if(l(e))Ie(e,n,t,o);else if(r(t))o.removeAttribute(e);else if(\"className\"===e)i?o.setAttribute(\"class\",t):o.className=t;else if(\"style\"===e)Te(n,t,o);else if(\"dangerouslySetInnerHTML\"===e){var f=n&&n.__html,d=t&&t.__html;f!==d&&(r(d)||(o.innerHTML=d))}else{var c=!!i&&wn[e];c?o.setAttributeNS(c,e,t):o.setAttribute(e,t)}}function De(e,n,t){if(e=e||jn,(n=n||jn)!==jn)for(var o in n)Ie(o,e[o],n[o],t);if(e!==jn)for(var i in e)r(n[i])&&Ie(i,e[i],null,t)}function Ie(e,n,t,o){if(n!==t){var l=e.toLowerCase(),a=o[l];if(a&&a.wrapped)return;if(On[e])_(e,n,t,o);else if(i(t)||r(t))o[l]=t;else{var u=t.event;u&&i(u)?(o._data||(o[l]=function(e){u(e.currentTarget._data,e)}),o._data=t.data):v()}}}function Te(e,n,t){var o=t.style;if(a(n))return void(o.cssText=n);for(var i in n){var l=n[i];!u(l)||i in _n?o[i]=l:o[i]=l+\"px\"}if(!r(e))for(var f in e)r(n[f])&&(o[f]=\"\")}function Pe(e,n,t){\"className\"===e?t.removeAttribute(\"class\"):\"value\"===e?t.value=\"\":\"style\"===e?t.removeAttribute(\"style\"):l(e)?_(name,n,null,t):t.removeAttribute(e)}function je(e,n,t,r,o){var i=e.flags;return 3970&i?Ae(e,n,t,r,o):28&i?Re(e,n,t,r,o,4&i):4096&i?Le(e,n):1&i?We(e,n):void v()}function We(e,n){var t=document.createTextNode(e.children);return e.dom=t,n&&Xe(n,t),t}function Le(e,n){var t=document.createTextNode(\"\");return e.dom=t,n&&Xe(n,t),t}function Ae(e,n,r,i,l){if(yn.recyclingEnabled){var a=ie(e,r,i,l);if(!f(a))return f(n)||Xe(n,a),a}var u=e.flags;(l||128&u)&&(l=!0);var d=Ze(e.type,l),c=e.children,s=e.props,v=e.events,p=e.ref;e.dom=d,o(c)||(t(c)?Je(d,c):gn(c)?ze(c,d,r,i,l):sn(c)&&je(c,d,r,i,l));var m=!1;if(2&u||(m=Y(u,e,d,!0)),!f(s))for(var h in s)Ve(h,null,s[h],d,l,m);if(!f(v))for(var g in v)Ie(g,null,v[g],d);return f(p)||Fe(d,p,r),f(n)||Xe(n,d),d}function ze(e,n,t,r,i){for(var l=0,a=e.length;l<a;l++){var u=e[l];o(u)||(u.dom&&(e[l]=u=un(u)),je(e[l],n,t,r,i))}}function Re(e,n,t,r,o,i){if(yn.recyclingEnabled){var l=ae(e,t,r,o);if(!f(l))return f(n)||Xe(n,l),l}var a,u=e.type,d=e.props||jn,c=e.ref;if(i){var s=Be(e,u,d,r,o),v=s._lastInput;s._vNode=e,e.dom=a=je(v,null,t,s._childContext,o),f(n)||Xe(n,a),Ke(e,c,s,t),yn.findDOMNodeEnabled&&Tn.set(s,a),e.children=s}else{var p=qe(e,u,d,r);e.dom=a=je(p,null,t,r,o),e.children=p,Ge(c,a,t),f(n)||Xe(n,a)}return a}function Ke(e,n,t,r){n&&(i(n)?n(t):v());var o=t.componentDidMount,l=yn.afterMount;c(o)&&f(l)?t._syncSetState=!0:r.addListener((function(){l&&l(e),o&&t.componentDidMount(),t._syncSetState=!0}))}function Ge(e,n,t){e&&(r(e.onComponentWillMount)||e.onComponentWillMount(),r(e.onComponentDidMount)||t.addListener((function(){return e.onComponentDidMount(n)})))}function Fe(e,n,t){if(i(n))t.addListener((function(){return n(e)}));else{if(o(n))return;v()}}function Be(e,n,i,l,a){c(l)&&(l=jn);var u=new n(i,l);u.context=l,u.props===jn&&(u.props=i),u._patch=Ce,yn.findDOMNodeEnabled&&(u._componentToDOMNodeMap=Tn),u._unmounted=!1,u._pendingSetState=!0,u._isSVG=a,c(u.componentWillMount)||u.componentWillMount();var f;c(u.getChildContext)||(f=u.getChildContext()),r(f)?u._childContext=l:u._childContext=p(l,f),yn.beforeRender&&yn.beforeRender(u);var d=u.render(i,u.state,l);return yn.afterRender&&yn.afterRender(u),gn(d)?v():o(d)?d=dn():t(d)?d=cn(d,null):(d.dom&&(d=un(d)),28&d.flags&&(d.parentVNode=e)),u._pendingSetState=!1,u._lastInput=d,u}function He(e,n,t,r,o,i,l){$e(t,je(n,null,r,o,i),e,r,l)}function $e(e,n,t,r,o){fe(t,null,r,!1,o),nn(e,n,t.dom)}function qe(e,n,r,i){var l=n(r,i);return gn(l)?v():o(l)?l=dn():t(l)?l=cn(l,null):(l.dom&&(l=un(l)),28&l.flags&&(l.parentVNode=e)),l}function Je(e,n){\"\"!==n?e.textContent=n:e.appendChild(document.createTextNode(\"\"))}function Ye(e,n){e.firstChild.nodeValue=n}function Xe(e,n){e.appendChild(n)}function Qe(e,n,t){r(t)?Xe(e,n):e.insertBefore(n,t)}function Ze(e,n){return n===!0?document.createElementNS(Cn,e):document.createElement(e)}function en(e,n,t,r,o,i,l){fe(e,null,r,!1,l);var a=je(n,null,r,o,i);n.dom=a,nn(t,a,e.dom)}function nn(e,n,t){e||(e=t.parentNode),e.replaceChild(n,t)}function tn(e,n){e.removeChild(n)}function rn(e,n,t,r){e.textContent=\"\",(!yn.recyclingEnabled||yn.recyclingEnabled&&!r)&&on(null,n,t,r)}function on(e,n,t,r){for(var i=0,l=n.length;i<l;i++){var a=n[i];o(a)||fe(a,e,t,!0,r)}}function ln(e,n){return n.length&&!r(n[0])&&!r(n[0].key)&&e.length&&!r(e[0])&&!r(e[0].key)}function an(e,t,r,o,i,l,a,u){16&e&&(e=n(t)?4:8);var f={children:c(o)?null:o,dom:null,events:i||null,flags:e,key:c(l)?null:l,props:r||null,ref:a||null,type:t};return u||w(f),yn.createVNode&&yn.createVNode(f),f}function un(e){var n,r=e.flags;if(28&r){var i,l=e.props;if(l){i={};for(var a in l)i[a]=l[a]}else i=jn;n=an(r,e.type,i,null,e.events,e.key,e.ref,!0);var u=n.props;if(u){var f=u.children;if(f)if(gn(f)){var d=f.length;if(d>0){for(var c=[],s=0;s<d;s++){var v=f[s];t(v)?c.push(v):!o(v)&&sn(v)&&c.push(un(v))}u.children=c}}else sn(f)&&(u.children=un(f))}n.children=null}else if(3970&r){var p,m=e.children,h=e.props;if(h){p={};for(var g in h)p[g]=h[g]}else p=jn;n=an(r,e.type,p,m,e.events,e.key,e.ref,!m)}else 1&r&&(n=cn(e.children,e.key));return n}function fn(e,n){for(var i=[],l=arguments.length-2;l-- >0;)i[l]=arguments[l+2];var a=i,u=i.length;u>0&&!c(i[0])&&(n||(n={}),1===u&&(a=i[0]),c(a)||(n.children=a));var f;if(gn(e)){for(var d=[],s=0,v=e.length;s<v;s++)d.push(un(e[s]));f=d}else{var m=e.flags,h=e.events||n&&n.events||null,g=r(e.key)?n?n.key:null:e.key,y=e.ref||(n?n.ref:null);if(28&m){f=an(m,e.type,e.props||n?p(e.props,n):jn,null,h,g,y,!0);var k=f.props;if(k){var b=k.children;if(b)if(gn(b)){var C=b.length;if(C>0){for(var N=[],x=0;x<C;x++){var w=b[x];t(w)?N.push(w):!o(w)&&sn(w)&&N.push(un(w))}k.children=N}}else sn(b)&&(k.children=un(b))}f.children=null}else 3970&m?(a=n&&!c(n.children)?n.children:e.children,f=an(m,e.type,e.props||n?p(e.props,n):jn,a,h,g,y,!a)):1&m&&(f=cn(e.children,g))}return f}function dn(){return an(4096)}function cn(e,n){return an(1,null,null,e,null,n)}function sn(e){return!!e.flags}function vn(e,n){return{data:e,event:n}}var pn=\"$NO_OP\",mn=\"a runtime error occured! Use Inferno in development environment to find the error.\",hn=\"undefined\"!=typeof window&&window.document,gn=Array.isArray;m.prototype.addListener=function(e){this.listeners.push(e)},m.prototype.trigger=function(){for(var e=this.listeners,n=0,t=e.length;n<t;n++)e[n]()};var yn={recyclingEnabled:!1,findDOMNodeEnabled:!1,roots:null,createVNode:null,beforeRender:null,afterRender:null,afterMount:null,afterUpdate:null,beforeUnmount:null},kn=\"http://www.w3.org/1999/xlink\",bn=\"http://www.w3.org/XML/1998/namespace\",Cn=\"http://www.w3.org/2000/svg\",Nn=Object.create(null);Nn.volume=!0,Nn.defaultChecked=!0,Object.freeze(Nn);var xn=Object.create(null);xn.muted=!0,xn.scoped=!0,xn.loop=!0,xn.open=!0,xn.checked=!0,xn.default=!0,xn.capture=!0,xn.disabled=!0,xn.readOnly=!0,xn.required=!0,xn.autoplay=!0,xn.controls=!0,xn.seamless=!0,xn.reversed=!0,xn.allowfullscreen=!0,xn.novalidate=!0,xn.hidden=!0,xn.autoFocus=!0,Object.freeze(xn);var wn=Object.create(null);wn[\"xlink:href\"]=kn,wn[\"xlink:arcrole\"]=kn,wn[\"xlink:actuate\"]=kn,wn[\"xlink:show\"]=kn,wn[\"xlink:role\"]=kn,wn[\"xlink:title\"]=kn,wn[\"xlink:type\"]=kn,wn[\"xml:base\"]=bn,wn[\"xml:lang\"]=bn,wn[\"xml:space\"]=bn,Object.freeze(wn);var _n=Object.create(null);_n.animationIterationCount=!0,_n.borderImageOutset=!0,_n.borderImageSlice=!0,_n.borderImageWidth=!0,_n.boxFlex=!0,_n.boxFlexGroup=!0,_n.boxOrdinalGroup=!0,_n.columnCount=!0,_n.flex=!0,_n.flexGrow=!0,_n.flexPositive=!0,_n.flexShrink=!0,_n.flexNegative=!0,_n.flexOrder=!0,_n.gridRow=!0,_n.gridColumn=!0,_n.fontWeight=!0,_n.lineClamp=!0,_n.lineHeight=!0,_n.opacity=!0,_n.order=!0,_n.orphans=!0,_n.tabSize=!0,_n.widows=!0,_n.zIndex=!0,_n.zoom=!0,_n.fillOpacity=!0,_n.floodOpacity=!0,_n.stopOpacity=!0,_n.strokeDasharray=!0,_n.strokeDashoffset=!0,_n.strokeMiterlimit=!0,_n.strokeOpacity=!0,_n.strokeWidth=!0,Object.freeze(_n);var Mn=Object.create(null);Mn.children=!0,Mn.childrenType=!0,Mn.defaultValue=!0,Mn.ref=!0,Mn.key=!0,Mn.selected=!0,Mn.checked=!0,Mn.multiple=!0,Object.freeze(Mn);var On=Object.create(null);On.onClick=!0,On.onMouseDown=!0,On.onMouseUp=!0,On.onMouseMove=!0,On.onSubmit=!0,On.onDblClick=!0,On.onKeyDown=!0,On.onKeyUp=!0,On.onKeyPress=!0,Object.freeze(On);var Sn=hn&&!!navigator.platform&&/iPad|iPhone|iPod/.test(navigator.platform),En=new Map,Un=new Map,Vn=new Map,Dn=new Map,In=[],Tn=new Map;yn.roots=In;var Pn=hn?document.body:null,jn={},Wn={linkEvent:vn,createVNode:an,cloneVNode:fn,NO_OP:pn,EMPTY_OBJ:jn,render:ke,findDOMNode:me,createRenderer:be,options:yn,version:\"1.4.0\"};e.version=\"1.4.0\",e.default=Wn,e.linkEvent=vn,e.createVNode=an,e.cloneVNode=fn,e.NO_OP=pn,e.EMPTY_OBJ=jn,e.render=ke,e.findDOMNode=me,e.createRenderer=be,e.options=yn,e.internal_isUnitlessNumber=_n,e.internal_normalize=w,Object.defineProperty(e,\"__esModule\",{value:!0})}));\n  })();\n});","\nrequire.register(\"path-parser/dist/commonjs/path-parser.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"path-parser\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _searchParams = require('search-params');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaultOrConstrained = function defaultOrConstrained(match) {\n    return '(' + (match ? match.replace(/(^<|>$)/g, '') : '[a-zA-Z0-9-_.~%\\':]+') + ')';\n};\n\nvar rules = [{\n    // An URL can contain a parameter :paramName\n    // - and _ are allowed but not in last position\n    name: 'url-parameter',\n    pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: function regex(match) {\n        return new RegExp(defaultOrConstrained(match[2]));\n    }\n}, {\n    // Url parameter (splat)\n    name: 'url-parameter-splat',\n    pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n    regex: /([^\\?]*)/\n}, {\n    name: 'url-parameter-matrix',\n    pattern: /^\\;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: function regex(match) {\n        return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));\n    }\n}, {\n    // Query parameter: ?param1&param2\n    //                   ?:param1&:param2\n    name: 'query-parameter-bracket',\n    pattern: /^(?:\\?|&)(?:\\:)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(?:\\[\\])/\n}, {\n    // Query parameter: ?param1&param2\n    //                   ?:param1&:param2\n    name: 'query-parameter',\n    pattern: /^(?:\\?|&)(?:\\:)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n}, {\n    // Delimiter /\n    name: 'delimiter',\n    pattern: /^(\\/|\\?)/,\n    regex: function regex(match) {\n        return new RegExp('\\\\' + match[0]);\n    }\n}, {\n    // Sub delimiters\n    name: 'sub-delimiter',\n    pattern: /^(\\!|\\&|\\-|_|\\.|;)/,\n    regex: function regex(match) {\n        return new RegExp(match[0]);\n    }\n}, {\n    // Unmatched fragment (until delimiter is found)\n    name: 'fragment',\n    pattern: /^([0-9a-zA-Z]+)/,\n    regex: function regex(match) {\n        return new RegExp(match[0]);\n    }\n}];\n\nvar exists = function exists(val) {\n    return val !== undefined && val !== null;\n};\n\nvar tokenise = function tokenise(str) {\n    var tokens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    // Look for a matching rule\n    var matched = rules.some(function (rule) {\n        var match = str.match(rule.pattern);\n        if (!match) return false;\n\n        tokens.push({\n            type: rule.name,\n            match: match[0],\n            val: match.slice(1, 2),\n            otherVal: match.slice(2),\n            regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n        });\n\n        if (match[0].length < str.length) tokens = tokenise(str.substr(match[0].length), tokens);\n        return true;\n    });\n\n    // If no rules matched, throw an error (possible malformed path)\n    if (!matched) {\n        throw new Error('Could not parse path.');\n    }\n    // Return tokens\n    return tokens;\n};\n\nvar optTrailingSlash = function optTrailingSlash(source, trailingSlash) {\n    if (!trailingSlash) return source;\n    return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?';\n};\n\nvar upToDelimiter = function upToDelimiter(source, delimiter) {\n    if (!delimiter) return source;\n\n    return (/(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)'\n    );\n};\n\nvar appendQueryParam = function appendQueryParam(params, param) {\n    var val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    if (/\\[\\]$/.test(param)) {\n        param = (0, _searchParams.withoutBrackets)(param);\n        val = [val];\n    }\n    var existingVal = params[param];\n\n    if (existingVal === undefined) params[param] = val;else params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];\n\n    return params;\n};\n\nvar parseQueryParams = function parseQueryParams(path) {\n    var searchPart = (0, _searchParams.getSearch)(path);\n    if (!searchPart) return {};\n\n    return (0, _searchParams.toObject)((0, _searchParams.parse)(searchPart));\n};\n\nfunction _serialise(key, val) {\n    if (Array.isArray(val)) {\n        return val.map(function (v) {\n            return _serialise(key, v);\n        }).join('&');\n    }\n\n    if (val === true) {\n        return key;\n    }\n\n    return key + '=' + val;\n}\n\nvar Path = function () {\n    _createClass(Path, null, [{\n        key: 'createPath',\n        value: function createPath(path) {\n            return new Path(path);\n        }\n    }, {\n        key: 'serialise',\n        value: function serialise(key, val) {\n            return _serialise(key, val);\n        }\n    }]);\n\n    function Path(path) {\n        _classCallCheck(this, Path);\n\n        if (!path) throw new Error('Please supply a path');\n        this.path = path;\n        this.tokens = tokenise(path);\n\n        this.hasUrlParams = this.tokens.filter(function (t) {\n            return (/^url-parameter/.test(t.type)\n            );\n        }).length > 0;\n        this.hasSpatParam = this.tokens.filter(function (t) {\n            return (/splat$/.test(t.type)\n            );\n        }).length > 0;\n        this.hasMatrixParams = this.tokens.filter(function (t) {\n            return (/matrix$/.test(t.type)\n            );\n        }).length > 0;\n        this.hasQueryParams = this.tokens.filter(function (t) {\n            return (/^query-parameter/.test(t.type)\n            );\n        }).length > 0;\n        // Extract named parameters from tokens\n        this.spatParams = this._getParams('url-parameter-splat');\n        this.urlParams = this._getParams(/^url-parameter/);\n        // Query params\n        this.queryParams = this._getParams('query-parameter');\n        this.queryParamsBr = this._getParams('query-parameter-bracket');\n        // All params\n        this.params = this.urlParams.concat(this.queryParams).concat(this.queryParamsBr);\n        // Check if hasQueryParams\n        // Regular expressions for url part only (full and partial match)\n        this.source = this.tokens.filter(function (t) {\n            return t.regex !== undefined;\n        }).map(function (r) {\n            return r.regex.source;\n        }).join('');\n    }\n\n    _createClass(Path, [{\n        key: '_getParams',\n        value: function _getParams(type) {\n            var predicate = type instanceof RegExp ? function (t) {\n                return type.test(t.type);\n            } : function (t) {\n                return t.type === type;\n            };\n\n            return this.tokens.filter(predicate).map(function (t) {\n                return t.val[0];\n            });\n        }\n    }, {\n        key: '_isQueryParam',\n        value: function _isQueryParam(name) {\n            return this.queryParams.indexOf(name) !== -1 || this.queryParamsBr.indexOf(name) !== -1;\n        }\n    }, {\n        key: '_urlTest',\n        value: function _urlTest(path, regex) {\n            var _this = this;\n\n            var match = path.match(regex);\n            if (!match) return null;else if (!this.urlParams.length) return {};\n            // Reduce named params to key-value pairs\n            return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {\n                params[_this.urlParams[i]] = decodeURIComponent(m);\n                return params;\n            }, {});\n        }\n    }, {\n        key: 'test',\n        value: function test(path, opts) {\n            var _this2 = this;\n\n            var options = _extends({ trailingSlash: false }, opts);\n            // trailingSlash: falsy => non optional, truthy => optional\n            var source = optTrailingSlash(this.source, options.trailingSlash);\n            // Check if exact match\n            var matched = this._urlTest(path, new RegExp('^' + source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$')));\n            // If no match, or no query params, no need to go further\n            if (!matched || !this.hasQueryParams) return matched;\n            // Extract query params\n            var queryParams = parseQueryParams(path);\n            var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {\n                return _this2.queryParams.concat(_this2.queryParamsBr).indexOf(p) === -1;\n            });\n\n            if (unexpectedQueryParams.length === 0) {\n                // Extend url match\n                Object.keys(queryParams).forEach(function (p) {\n                    return matched[p] = queryParams[p];\n                });\n\n                return matched;\n            }\n\n            return null;\n        }\n    }, {\n        key: 'partialTest',\n        value: function partialTest(path, opts) {\n            var _this3 = this;\n\n            var options = _extends({ delimited: true }, opts);\n            // Check if partial match (start of given path matches regex)\n            // trailingSlash: falsy => non optional, truthy => optional\n            var source = upToDelimiter(this.source, options.delimited);\n            var match = this._urlTest(path, new RegExp('^' + source));\n\n            if (!match) return match;\n\n            if (!this.hasQueryParams) return match;\n\n            var queryParams = parseQueryParams(path);\n\n            Object.keys(queryParams).filter(function (p) {\n                return _this3.queryParams.concat(_this3.queryParamsBr).indexOf(p) >= 0;\n            }).forEach(function (p) {\n                return appendQueryParam(match, p, queryParams[p]);\n            });\n\n            return match;\n        }\n    }, {\n        key: 'build',\n        value: function build() {\n            var _this4 = this;\n\n            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var options = _extends({ ignoreConstraints: false, ignoreSearch: false }, opts);\n            var encodedParams = Object.keys(params).reduce(function (acc, key) {\n                if (!exists(params[key])) {\n                    return acc;\n                }\n\n                var val = params[key];\n                var encode = _this4._isQueryParam(key) ? encodeURIComponent : encodeURI;\n\n                if (typeof val === 'boolean') {\n                    acc[key] = val;\n                } else if (Array.isArray(val)) {\n                    acc[key] = val.map(encode);\n                } else {\n                    acc[key] = encode(val);\n                }\n\n                return acc;\n            }, {});\n\n            // Check all params are provided (not search parameters which are optional)\n            if (this.urlParams.some(function (p) {\n                return !exists(encodedParams[p]);\n            })) throw new Error('Missing parameters');\n\n            // Check constraints\n            if (!options.ignoreConstraints) {\n                var constraintsPassed = this.tokens.filter(function (t) {\n                    return (/^url-parameter/.test(t.type) && !/-splat$/.test(t.type)\n                    );\n                }).every(function (t) {\n                    return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedParams[t.val]);\n                });\n\n                if (!constraintsPassed) throw new Error('Some parameters are of invalid format');\n            }\n\n            var base = this.tokens.filter(function (t) {\n                return (/^query-parameter/.test(t.type) === false\n                );\n            }).map(function (t) {\n                if (t.type === 'url-parameter-matrix') return ';' + t.val + '=' + encodedParams[t.val[0]];\n                return (/^url-parameter/.test(t.type) ? encodedParams[t.val[0]] : t.match\n                );\n            }).join('');\n\n            if (options.ignoreSearch) return base;\n\n            var queryParams = this.queryParams.concat(this.queryParamsBr.map(function (p) {\n                return p + '[]';\n            }));\n\n            var searchPart = queryParams.filter(function (p) {\n                return Object.keys(encodedParams).indexOf((0, _searchParams.withoutBrackets)(p)) !== -1;\n            }).map(function (p) {\n                return _serialise(p, encodedParams[(0, _searchParams.withoutBrackets)(p)]);\n            }).join('&');\n\n            return base + (searchPart ? '?' + searchPart : '');\n        }\n    }]);\n\n    return Path;\n}();\n\nexports.default = Path;\nmodule.exports = exports['default'];\n  })();\n});","\nrequire.register(\"process/browser.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"process\");\n  (function() {\n    // shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n  })();\n});","\nrequire.register(\"route-node/dist/commonjs/route-node.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"route-node\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _pathParser = require('path-parser');\n\nvar _pathParser2 = _interopRequireDefault(_pathParser);\n\nvar _searchParams = require('search-params');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar noop = function noop() {};\n\nvar RouteNode = function () {\n    function RouteNode() {\n        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        var childRoutes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        var cb = arguments[3];\n        var parent = arguments[4];\n\n        _classCallCheck(this, RouteNode);\n\n        this.name = name;\n        this.absolute = /^~/.test(path);\n        this.path = this.absolute ? path.slice(1) : path;\n        this.parser = this.path ? new _pathParser2.default(this.path) : null;\n        this.children = [];\n        this.parent = parent;\n\n        this.checkParents();\n\n        this.add(childRoutes, cb);\n\n        return this;\n    }\n\n    _createClass(RouteNode, [{\n        key: 'checkParents',\n        value: function checkParents() {\n            if (this.absolute && this.hasParentsParams()) {\n                throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');\n            }\n        }\n    }, {\n        key: 'hasParentsParams',\n        value: function hasParentsParams() {\n            if (this.parent && this.parent.parser) {\n                var parser = this.parent.parser;\n                var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;\n\n                return hasParams || this.parent.hasParentsParams();\n            }\n\n            return false;\n        }\n    }, {\n        key: 'getNonAbsoluteChildren',\n        value: function getNonAbsoluteChildren() {\n            return this.children.filter(function (child) {\n                return !child.absolute;\n            });\n        }\n    }, {\n        key: 'findAbsoluteChildren',\n        value: function findAbsoluteChildren() {\n            return this.children.reduce(function (absoluteChildren, child) {\n                return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());\n            }, []);\n        }\n    }, {\n        key: 'findSlashChild',\n        value: function findSlashChild() {\n            var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {\n                return child.parser && /^\\/(\\?|$)/.test(child.parser.path);\n            });\n\n            return slashChildren[0];\n        }\n    }, {\n        key: 'getParentSegments',\n        value: function getParentSegments() {\n            var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n            return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();\n        }\n    }, {\n        key: 'setParent',\n        value: function setParent(parent) {\n            this.parent = parent;\n            this.checkParents();\n        }\n    }, {\n        key: 'setPath',\n        value: function setPath() {\n            var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n            this.path = path;\n            this.parser = path ? new _pathParser2.default(path) : null;\n        }\n    }, {\n        key: 'add',\n        value: function add(route) {\n            var _this = this;\n\n            var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n\n            var originalRoute = void 0;\n            if (route === undefined || route === null) return;\n\n            if (route instanceof Array) {\n                route.forEach(function (r) {\n                    return _this.add(r, cb);\n                });\n                return;\n            }\n\n            if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n                throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');\n            } else if (route instanceof RouteNode) {\n                route.setParent(this);\n            } else {\n                if (!route.name || !route.path) {\n                    throw new Error('RouteNode.add() expects routes to have a name and a path defined.');\n                }\n                originalRoute = route;\n                route = new RouteNode(route.name, route.path, route.children, cb, this);\n            }\n\n            var names = route.name.split('.');\n\n            if (names.length === 1) {\n                // Check duplicated routes\n                if (this.children.map(function (child) {\n                    return child.name;\n                }).indexOf(route.name) !== -1) {\n                    throw new Error('Alias \"' + route.name + '\" is already defined in route node');\n                }\n\n                // Check duplicated paths\n                if (this.children.map(function (child) {\n                    return child.path;\n                }).indexOf(route.path) !== -1) {\n                    throw new Error('Path \"' + route.path + '\" is already defined in route node');\n                }\n\n                this.children.push(route);\n                // Push greedy spats to the bottom of the pile\n                this.children.sort(function (left, right) {\n                    var leftPath = left.path.split('?')[0].replace(/(.+)\\/$/, '$1');\n                    var rightPath = right.path.split('?')[0].replace(/(.+)\\/$/, '$1');\n                    // '/' last\n                    if (leftPath === '/') return 1;\n                    if (rightPath === '/') return -1;\n                    // Spat params last\n                    if (left.parser.hasSpatParam) return 1;\n                    if (right.parser.hasSpatParam) return -1;\n                    // No spat, number of segments (less segments last)\n                    var leftSegments = (leftPath.match(/\\//g) || []).length;\n                    var rightSegments = (rightPath.match(/\\//g) || []).length;\n                    if (leftSegments < rightSegments) return 1;\n                    if (leftSegments > rightSegments) return -1;\n                    // Same number of segments, number of URL params ascending\n                    var leftParamsCount = left.parser.urlParams.length;\n                    var rightParamsCount = right.parser.urlParams.length;\n                    if (leftParamsCount < rightParamsCount) return -1;\n                    if (leftParamsCount > rightParamsCount) return 1;\n                    // Same number of segments and params, last segment length descending\n                    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;\n                    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;\n                    if (leftParamLength < rightParamLength) return 1;\n                    if (leftParamLength > rightParamLength) return -1;\n                    // Same last segment length, preserve definition order\n                    return 0;\n                });\n            } else {\n                // Locate parent node\n                var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));\n                if (segments) {\n                    route.name = names[names.length - 1];\n                    segments[segments.length - 1].add(route);\n                } else {\n                    throw new Error('Could not add route named \\'' + route.name + '\\', parent is missing.');\n                }\n            }\n\n            if (originalRoute) {\n                var fullName = route.getParentSegments([route]).map(function (_) {\n                    return _.name;\n                }).join('.');\n                cb(_extends({}, originalRoute, {\n                    name: fullName\n                }));\n            }\n\n            return this;\n        }\n    }, {\n        key: 'addNode',\n        value: function addNode(name, params) {\n            this.add(new RouteNode(name, params));\n            return this;\n        }\n    }, {\n        key: 'getSegmentsByName',\n        value: function getSegmentsByName(routeName) {\n            var findSegmentByName = function findSegmentByName(name, routes) {\n                var filteredRoutes = routes.filter(function (r) {\n                    return r.name === name;\n                });\n                return filteredRoutes.length ? filteredRoutes[0] : undefined;\n            };\n            var segments = [];\n            var routes = this.parser ? [this] : this.children;\n            var names = (this.parser ? [''] : []).concat(routeName.split('.'));\n\n            var matched = names.every(function (name) {\n                var segment = findSegmentByName(name, routes);\n                if (segment) {\n                    routes = segment.children;\n                    segments.push(segment);\n                    return true;\n                }\n                return false;\n            });\n\n            return matched ? segments : null;\n        }\n    }, {\n        key: 'getSegmentsMatchingPath',\n        value: function getSegmentsMatchingPath(path, options) {\n            var trailingSlash = options.trailingSlash,\n                strictQueryParams = options.strictQueryParams,\n                strongMatching = options.strongMatching;\n\n            var matchChildren = function matchChildren(nodes, pathSegment, segments) {\n                var isRoot = nodes.length === 1 && nodes[0].name === '';\n                // for (child of node.children) {\n\n                var _loop = function _loop(i) {\n                    var child = nodes[i];\n\n                    // Partially match path\n                    var match = void 0;\n                    var remainingPath = void 0;\n\n                    if (!child.children.length) {\n                        match = child.parser.test(pathSegment, { trailingSlash: trailingSlash });\n                    }\n\n                    if (!match) {\n                        match = child.parser.partialTest(pathSegment, { delimiter: strongMatching });\n                    }\n\n                    if (match) {\n                        // Remove consumed segment from path\n                        var consumedPath = child.parser.build(match, { ignoreSearch: true });\n                        if (trailingSlash && !child.children.length) {\n                            consumedPath = consumedPath.replace(/\\/$/, '');\n                        }\n                        remainingPath = pathSegment.replace(consumedPath, '');\n                        var search = (0, _searchParams.omit)((0, _searchParams.getSearch)(pathSegment.replace(consumedPath, '')), child.parser.queryParams.concat(child.parser.queryParamsBr));\n                        remainingPath = (0, _searchParams.getPath)(remainingPath) + (search ? '?' + search : '');\n                        if (trailingSlash && !isRoot && remainingPath === '/' && !/\\/$/.test(consumedPath)) {\n                            remainingPath = '';\n                        }\n\n                        segments.push(child);\n                        Object.keys(match).forEach(function (param) {\n                            return segments.params[param] = match[param];\n                        });\n\n                        if (!isRoot && !remainingPath.length) {\n                            // fully matched\n                            return {\n                                v: segments\n                            };\n                        }\n                        if (!isRoot && !strictQueryParams && remainingPath.indexOf('?') === 0) {\n                            // unmatched queryParams in non strict mode\n                            var remainingQueryParams = (0, _searchParams.parse)(remainingPath.slice(1));\n\n                            remainingQueryParams.forEach(function (_ref) {\n                                var name = _ref.name,\n                                    value = _ref.value;\n                                return segments.params[name] = value;\n                            });\n                            return {\n                                v: segments\n                            };\n                        }\n                        // Continue matching on non absolute children\n                        var children = child.getNonAbsoluteChildren();\n                        // If no children to match against but unmatched path left\n                        if (!children.length) {\n                            return {\n                                v: null\n                            };\n                        }\n                        // Else: remaining path and children\n                        return {\n                            v: matchChildren(children, remainingPath, segments)\n                        };\n                    }\n                };\n\n                for (var i = 0; i < nodes.length; i += 1) {\n                    var _ret = _loop(i);\n\n                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n                }\n\n                return null;\n            };\n\n            var topLevelNodes = this.parser ? [this] : this.children;\n            var startingNodes = topLevelNodes.reduce(function (nodes, node) {\n                return nodes.concat(node, node.findAbsoluteChildren());\n            }, []);\n\n            var segments = [];\n            segments.params = {};\n\n            var matched = matchChildren(startingNodes, path, segments);\n            if (matched && matched.length === 1 && matched[0].name === '') return null;\n            return matched;\n        }\n    }, {\n        key: 'getPathFromSegments',\n        value: function getPathFromSegments(segments) {\n            return segments ? segments.map(function (segment) {\n                return segment.path;\n            }).join('') : null;\n        }\n    }, {\n        key: 'getPath',\n        value: function getPath(routeName) {\n            return this.getPathFromSegments(this.getSegmentsByName(routeName));\n        }\n    }, {\n        key: 'buildPathFromSegments',\n        value: function buildPathFromSegments(segments) {\n            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            if (!segments) return null;\n\n            var searchParams = [];\n            var nonSearchParams = [];\n\n            for (var i = 0; i < segments.length; i += 1) {\n                var parser = segments[i].parser;\n                searchParams.push.apply(searchParams, _toConsumableArray(parser.queryParams));\n                searchParams.push.apply(searchParams, _toConsumableArray(parser.queryParamsBr));\n                nonSearchParams.push.apply(nonSearchParams, _toConsumableArray(parser.urlParams));\n                nonSearchParams.push.apply(nonSearchParams, _toConsumableArray(parser.spatParams));\n            }\n\n            if (!options.strictQueryParams) {\n                var extraParams = Object.keys(params).reduce(function (acc, p) {\n                    return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;\n                }, []);\n                searchParams.push.apply(searchParams, _toConsumableArray(extraParams));\n            }\n\n            var searchPart = !searchParams.length ? null : searchParams.filter(function (p) {\n                if (Object.keys(params).indexOf((0, _searchParams.withoutBrackets)(p)) === -1) {\n                    return false;\n                }\n\n                var val = params[(0, _searchParams.withoutBrackets)(p)];\n\n                return val !== undefined && val !== null;\n            }).map(function (p) {\n                var val = params[(0, _searchParams.withoutBrackets)(p)];\n                var encodedVal = Array.isArray(val) ? val.map(encodeURIComponent) : encodeURIComponent(val);\n\n                return _pathParser2.default.serialise(p, encodedVal);\n            }).join('&');\n\n            var path = segments.reduce(function (path, segment) {\n                var segmentPath = segment.parser.build(params, { ignoreSearch: true });\n\n                return segment.absolute ? segmentPath : path + segmentPath;\n            }, '');\n\n            return path + (searchPart ? '?' + searchPart : '');\n        }\n    }, {\n        key: 'getMetaFromSegments',\n        value: function getMetaFromSegments(segments) {\n            var accName = '';\n\n            return segments.reduce(function (meta, segment) {\n                var urlParams = segment.parser.urlParams.reduce(function (params, p) {\n                    params[p] = 'url';\n                    return params;\n                }, {});\n\n                var allParams = segment.parser.queryParams.reduce(function (params, p) {\n                    params[p] = 'query';\n                    return params;\n                }, urlParams);\n\n                if (segment.name !== undefined) {\n                    accName = accName ? accName + '.' + segment.name : segment.name;\n                    meta[accName] = allParams;\n                }\n                return meta;\n            }, {});\n        }\n    }, {\n        key: 'buildPath',\n        value: function buildPath(routeName) {\n            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            var defaultOptions = { strictQueryParams: true };\n            var options = _extends({}, defaultOptions, opts);\n            var path = this.buildPathFromSegments(this.getSegmentsByName(routeName), params, options);\n\n            if (options.trailingSlash === true) {\n                return (/\\/$/.test(path) ? path : path + '/'\n                );\n            } else if (options.trailingSlash === false) {\n                return (/\\/$/.test(path) ? path.slice(0, -1) : path\n                );\n            }\n\n            return path;\n        }\n    }, {\n        key: 'buildStateFromSegments',\n        value: function buildStateFromSegments(segments) {\n            if (!segments || !segments.length) return null;\n\n            var name = segments.map(function (segment) {\n                return segment.name;\n            }).filter(function (name) {\n                return name;\n            }).join('.');\n            var params = segments.params;\n\n            return {\n                name: name,\n                params: params,\n                _meta: this.getMetaFromSegments(segments)\n            };\n        }\n    }, {\n        key: 'buildState',\n        value: function buildState(name) {\n            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var segments = this.getSegmentsByName(name);\n            if (!segments || !segments.length) return null;\n\n            return {\n                name: name,\n                params: params,\n                _meta: this.getMetaFromSegments(segments)\n            };\n        }\n    }, {\n        key: 'matchPath',\n        value: function matchPath(path, options) {\n            var defaultOptions = { trailingSlash: false, strictQueryParams: true, strongMatching: true };\n            var opts = _extends({}, defaultOptions, options);\n            var matchedSegments = this.getSegmentsMatchingPath(path, opts);\n\n            if (matchedSegments) {\n                if (matchedSegments[0].absolute) {\n                    var firstSegmentParams = matchedSegments[0].getParentSegments();\n\n                    matchedSegments.reverse();\n                    matchedSegments.push.apply(matchedSegments, _toConsumableArray(firstSegmentParams));\n                    matchedSegments.reverse();\n                }\n\n                var lastSegment = matchedSegments[matchedSegments.length - 1];\n                var lastSegmentSlashChild = lastSegment.findSlashChild();\n\n                if (lastSegmentSlashChild) {\n                    matchedSegments.push(lastSegmentSlashChild);\n                }\n            }\n\n            return this.buildStateFromSegments(matchedSegments);\n        }\n    }]);\n\n    return RouteNode;\n}();\n\nexports.default = RouteNode;\nmodule.exports = exports['default'];\n  })();\n});","\nrequire.register(\"router5.transition-path/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5.transition-path\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.nameToIDs = nameToIDs;\nfunction nameToIDs(name) {\n    return name.split('.').reduce(function (ids, name) {\n        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);\n    }, []);\n}\n\nfunction exists(val) {\n    return val !== undefined && val !== null;\n}\n\nfunction hasMetaParams(state) {\n    return state && state.meta && state.meta.params;\n}\n\nfunction extractSegmentParams(name, state) {\n    if (!exists(state.meta.params[name])) return {};\n\n    return Object.keys(state.meta.params[name]).reduce(function (params, p) {\n        params[p] = state.params[p];\n        return params;\n    }, {});\n}\n\nfunction transitionPath(toState, fromState) {\n    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];\n    var toStateIds = nameToIDs(toState.name);\n    var maxI = Math.min(fromStateIds.length, toStateIds.length);\n\n    function pointOfDifference() {\n        var i = void 0;\n\n        var _loop = function _loop() {\n            var left = fromStateIds[i];\n            var right = toStateIds[i];\n\n            if (left !== right) return {\n                    v: i\n                };\n\n            var leftParams = extractSegmentParams(left, toState);\n            var rightParams = extractSegmentParams(right, fromState);\n\n            if (leftParams.length !== rightParams.length) return {\n                    v: i\n                };\n            if (leftParams.length === 0) return 'continue';\n\n            var different = Object.keys(leftParams).some(function (p) {\n                return rightParams[p] !== leftParams[p];\n            });\n            if (different) {\n                return {\n                    v: i\n                };\n            }\n        };\n\n        for (i = 0; i < maxI; i += 1) {\n            var _ret = _loop();\n\n            switch (_ret) {\n                case 'continue':\n                    continue;\n\n                default:\n                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n            }\n        }\n\n        return i;\n    }\n\n    var i = void 0;\n    if (!fromState) {\n        i = 0;\n    } else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {\n        console.warn('[router5.transition-path] Some states are missing metadata, reloading all segments');\n        i = 0;\n    } else {\n        i = pointOfDifference();\n    }\n\n    var toDeactivate = fromStateIds.slice(i).reverse();\n    var toActivate = toStateIds.slice(i);\n\n    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';\n\n    return {\n        intersection: intersection,\n        toDeactivate: toDeactivate,\n        toActivate: toActivate\n    };\n}\n\nexports.default = transitionPath;\n  })();\n});","\nrequire.register(\"router5/constants.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar errorCodes = exports.errorCodes = {\n    ROUTER_NOT_STARTED: 'NOT_STARTED',\n    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',\n    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',\n    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',\n    SAME_STATES: 'SAME_STATES',\n    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',\n    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',\n    TRANSITION_ERR: 'TRANSITION_ERR',\n    TRANSITION_CANCELLED: 'CANCELLED'\n};\n\nvar constants = {\n    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',\n    ROUTER_START: '$start',\n    ROUTER_STOP: '$stop',\n    TRANSITION_START: '$$start',\n    TRANSITION_CANCEL: '$$cancel',\n    TRANSITION_SUCCESS: '$$success',\n    TRANSITION_ERROR: '$$error'\n};\n\nexports.default = constants;\n  })();\n});","\nrequire.register(\"router5/core/clone.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    \"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = withCloning;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction withCloning(router, createRouter) {\n    router.clone = clone;\n\n    /**\n     * Clone the current router configuration. The new returned router will be non-started,\n     * with a null state\n     * @param  {[type]} deps [description]\n     * @return {[type]}      [description]\n     */\n    function clone() {\n        var deps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var clonedDependencies = _extends({}, router.getDependencies(), deps);\n        var clonedRouter = createRouter(router.rootNode, router.getOptions(), clonedDependencies);\n\n        clonedRouter.useMiddleware.apply(clonedRouter, _toConsumableArray(router.getMiddlewareFactories()));\n        clonedRouter.usePlugin.apply(clonedRouter, _toConsumableArray(router.getPlugins()));\n\n        var _router$getLifecycleF = router.getLifecycleFactories(),\n            _router$getLifecycleF2 = _slicedToArray(_router$getLifecycleF, 2),\n            canDeactivateFactories = _router$getLifecycleF2[0],\n            canActivateFactories = _router$getLifecycleF2[1];\n\n        Object.keys(canDeactivateFactories).forEach(function (name) {\n            return clonedRouter.canDeactivate(name, canDeactivateFactories[name]);\n        });\n        Object.keys(canActivateFactories).forEach(function (name) {\n            return clonedRouter.canActivate(name, canActivateFactories[name]);\n        });\n\n        return clonedRouter;\n    }\n};\n  })();\n});","\nrequire.register(\"router5/core/middleware.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    \"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withMiddleware;\nfunction withMiddleware(router) {\n    var middlewareFactories = [];\n    var middlewareFunctions = [];\n\n    router.useMiddleware = useMiddleware;\n    router.getMiddlewareFactories = getMiddlewareFactories;\n    router.getMiddlewareFunctions = getMiddlewareFunctions;\n    router.clearMiddleware = clearMiddleware;\n\n    /**\n     * Register middleware functions.\n     * @param  {...Function} middlewares The middleware functions\n     * @return {Object}                  The router instance\n     */\n    function useMiddleware() {\n        for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n            middlewares[_key] = arguments[_key];\n        }\n\n        middlewares.forEach(addMiddleware);\n\n        return router;\n    }\n\n    /**\n     * Remove all middleware functions\n     * @return {Object} The router instance\n     */\n    function clearMiddleware() {\n        middlewareFactories = [];\n        middlewareFunctions = [];\n\n        return router;\n    }\n\n    function getMiddlewareFactories() {\n        return middlewareFactories;\n    }\n\n    function getMiddlewareFunctions() {\n        return middlewareFunctions;\n    }\n\n    function addMiddleware(middleware) {\n        middlewareFactories.push(middleware);\n        middlewareFunctions.push(router.executeFactory(middleware));\n    }\n}\n  })();\n});","\nrequire.register(\"router5/core/navigation.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = withNavigation;\n\nvar _constants = require('../constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nvar _transition = require('../transition');\n\nvar _transition2 = _interopRequireDefault(_transition);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {};\n\nfunction withNavigation(router) {\n    var cancelCurrentTransition = void 0;\n\n    router.navigate = navigate;\n    router.navigateToDefault = navigateToDefault;\n    router.transitionToState = transitionToState;\n    router.cancel = cancel;\n\n    /**\n     * Cancel the current transition if there is one\n     * @return {Object} The router instance\n     */\n    function cancel() {\n        if (cancelCurrentTransition) {\n            cancelCurrentTransition('navigate');\n            cancelCurrentTransition = null;\n        }\n\n        return router;\n    }\n\n    /**\n     * Navigate to a route\n     * @param  {String}   routeName      The route name\n     * @param  {Object}   [routeParams]  The route params\n     * @param  {Object}   [options]      The navigation options (`replace`, `reload`)\n     * @param  {Function} [done]         A done node style callback (err, state)\n     * @return {Function}                A cancel function\n     */\n    function navigate() {\n        var _ref;\n\n        var name = arguments.length <= 0 ? undefined : arguments[0];\n        var lastArg = (_ref = arguments.length - 1, arguments.length <= _ref ? undefined : arguments[_ref]);\n        var done = typeof lastArg === 'function' ? lastArg : noop;\n        var params = _typeof(arguments.length <= 1 ? undefined : arguments[1]) === 'object' ? arguments.length <= 1 ? undefined : arguments[1] : {};\n        var opts = _typeof(arguments.length <= 2 ? undefined : arguments[2]) === 'object' ? arguments.length <= 2 ? undefined : arguments[2] : {};\n\n        if (!router.isStarted()) {\n            done({ code: _constants.errorCodes.ROUTER_NOT_STARTED });\n            return;\n        }\n\n        var route = router.buildState(name, params);\n\n        if (!route) {\n            var err = { code: _constants.errorCodes.ROUTE_NOT_FOUND };\n            done(err);\n            router.invokeEventListeners(_constants2.default.TRANSITION_ERROR, null, router.getState(), err);\n            return;\n        }\n\n        var toState = router.makeState(route.name, route.params, router.buildPath(name, params), route._meta);\n        var sameStates = router.getState() ? router.areStatesEqual(router.getState(), toState, false) : false;\n\n        // Do not proceed further if states are the same and no reload\n        // (no desactivation and no callbacks)\n        if (sameStates && !opts.reload) {\n            var _err = { code: _constants.errorCodes.SAME_STATES };\n            done(_err);\n            router.invokeEventListeners(_constants2.default.TRANSITION_ERROR, toState, router.getState(), _err);\n            return;\n        }\n\n        var fromState = sameStates ? null : router.getState();\n\n        // Transitio\n        return transitionToState(toState, fromState, opts, function (err, state) {\n            if (err) {\n                if (err.redirect) {\n                    var _err$redirect = err.redirect,\n                        _name = _err$redirect.name,\n                        _params = _err$redirect.params;\n\n\n                    navigate(_name, _params, _extends({}, opts, { reload: true }), done);\n                } else {\n                    done(err);\n                }\n            } else {\n                router.invokeEventListeners(_constants2.default.TRANSITION_SUCCESS, state, fromState, opts);\n                done(null, state);\n            }\n        });\n    }\n\n    /**\n     * Navigate to the default route (if defined)\n     * @param  {Object}   [opts] The navigation options\n     * @param  {Function} [done] A done node style callback (err, state)\n     * @return {Function}        A cancel function\n     */\n    function navigateToDefault() {\n        var opts = _typeof(arguments.length <= 0 ? undefined : arguments[0]) === 'object' ? arguments.length <= 0 ? undefined : arguments[0] : {};\n        var done = arguments.length === 2 ? arguments.length <= 1 ? undefined : arguments[1] : typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function' ? arguments.length <= 0 ? undefined : arguments[0] : noop;\n        var options = router.getOptions();\n\n        if (options.defaultRoute) {\n            return navigate(options.defaultRoute, options.defaultParams, opts, done);\n        }\n\n        return function () {};\n    }\n\n    function transitionToState(toState, fromState) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var done = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n\n        cancel();\n        router.invokeEventListeners(_constants2.default.TRANSITION_START, toState, fromState);\n\n        cancelCurrentTransition = (0, _transition2.default)(router, toState, fromState, options, function (err, state) {\n            cancelCurrentTransition = null;\n            state = state || toState;\n\n            if (err) {\n                if (err.code === _constants.errorCodes.TRANSITION_CANCELLED) {\n                    router.invokeEventListeners(_constants2.default.TRANSITION_CANCEL, toState, fromState);\n                } else {\n                    router.invokeEventListeners(_constants2.default.TRANSITION_ERROR, toState, fromState, err);\n                }\n                done(err);\n            } else {\n                router.setState(state);\n                done(null, state);\n            }\n        });\n\n        return cancelCurrentTransition;\n    }\n}\n  })();\n});","\nrequire.register(\"router5/core/plugins.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withPlugins;\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar pluginMethods = ['onStart', 'onStop', 'onTransitionSuccess', 'onTransitionStart', 'onTransitionError', 'onTransitionCancel'];\n\nfunction withPlugins(router) {\n    var plugins = [];\n    var removePluginListeners = [];\n\n    router.usePlugin = usePlugin;\n    router.hasPlugin = hasPlugin;\n    router.getPlugins = getPlugins;\n\n    function getPlugins() {\n        return plugins;\n    }\n\n    /**\n     * Use plugins\n     * @param  {...Function} plugins An argument list of plugins\n     * @return {Object}              The router instance\n     */\n    function usePlugin() {\n        for (var _len = arguments.length, plugins = Array(_len), _key = 0; _key < _len; _key++) {\n            plugins[_key] = arguments[_key];\n        }\n\n        plugins.forEach(addPlugin);\n        return router;\n    }\n\n    function addPlugin(plugin) {\n        if (!hasPlugin(plugin)) {\n            plugins.push(plugin);\n            startPlugin(plugin);\n        }\n    }\n\n    /**\n     * Check if a plugin has already been registered.\n     * @param  {String}  pluginName The plugin name\n     * @return {Boolean}            Whether the plugin has been registered\n     */\n    function hasPlugin(pluginName) {\n        return plugins.filter(function (p) {\n            return p.pluginName === pluginName || p.name === pluginName;\n        }).length > 0;\n    }\n\n    function startPlugin(plugin) {\n        var appliedPlugin = router.executeFactory(plugin);\n\n        var removeEventListeners = pluginMethods.map(function (methodName) {\n            if (appliedPlugin[methodName]) {\n                return router.addEventListener(methodName.toLowerCase().replace(/^on/, '$$').replace(/transition/, '$$'), appliedPlugin[methodName]);\n            }\n        }).filter(Boolean);\n\n        removePluginListeners.push.apply(removePluginListeners, _toConsumableArray(removeEventListeners));\n    }\n}\n  })();\n});","\nrequire.register(\"router5/core/route-lifecycle.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withRouteLifecycle;\nvar toFunction = function toFunction(val) {\n    return typeof val === 'function' ? val : function () {\n        return function () {\n            return val;\n        };\n    };\n};\n\nfunction withRouteLifecycle(router) {\n    var canDeactivateFactories = {};\n    var canActivateFactories = {};\n    var canDeactivateFunctions = {};\n    var canActivateFunctions = {};\n\n    router.canDeactivate = canDeactivate;\n    router.canActivate = canActivate;\n    router.getLifecycleFactories = getLifecycleFactories;\n    router.getLifecycleFunctions = getLifecycleFunctions;\n    router.clearCanDeactivate = clearCanDeactivate;\n\n    function getLifecycleFactories() {\n        return [canDeactivateFactories, canActivateFactories];\n    }\n\n    function getLifecycleFunctions() {\n        return [canDeactivateFunctions, canActivateFunctions];\n    }\n\n    /**\n     * Register a canDeactivate handler or specify a if a route can be deactivated\n     * @param  {String} name                           The route name\n     * @param  {Function|Boolean} canDeactivateHandler The canDeactivate handler or boolean\n     * @return {Object}                                The router instance\n     */\n    function canDeactivate(name, canDeactivateHandler) {\n        var factory = toFunction(canDeactivateHandler);\n\n        canDeactivateFactories[name] = factory;\n        canDeactivateFunctions[name] = router.executeFactory(factory);\n\n        return router;\n    }\n\n    /**\n     * Remove a canDeactivate handler for a route\n     * @param  {String} name The route name\n     * @return {Object}      The router instance\n     */\n    function clearCanDeactivate(name) {\n        canDeactivateFactories[name] = undefined;\n        canDeactivateFunctions[name] = undefined;\n\n        return router;\n    }\n\n    /**\n     * Register a canActivate handler or specify a if a route can be deactivated\n     * @param  {String} name                         The route name\n     * @param  {Function|Boolean} canActivateHandler The canActivate handler or boolean\n     * @return {Object}                              The router instance\n     */\n    function canActivate(name, canActivateHandler) {\n        var factory = toFunction(canActivateHandler);\n\n        canActivateFactories[name] = factory;\n        canActivateFunctions[name] = router.executeFactory(factory);\n\n        return router;\n    }\n}\n  })();\n});","\nrequire.register(\"router5/core/router-lifecycle.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = withRouterLifecycle;\n\nvar _constants = require('../constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar noop = function noop() {};\n\nfunction withRouterLifecycle(router) {\n    var started = false;\n    var options = router.getOptions();\n\n    router.isStarted = isStarted;\n    router.start = start;\n    router.stop = stop;\n\n    /**\n     * Check if the router is started\n     * @return {Boolean} Whether the router is started or not\n     */\n    function isStarted() {\n        return started;\n    }\n\n    /**\n     * Start the router\n     * @param  {String|Object} startPathOrState The start path or state. This is optional when using the browser plugin.\n     * @param  {Function}      done             A done node style callback (err, state)\n     * @return {Object}                         The router instance\n     */\n    function start() {\n        var _ref;\n\n        var lastArg = (_ref = arguments.length - 1, arguments.length <= _ref ? undefined : arguments[_ref]);\n        var done = typeof lastArg === 'function' ? lastArg : noop;\n        var startPathOrState = typeof (arguments.length <= 0 ? undefined : arguments[0]) !== 'function' ? arguments.length <= 0 ? undefined : arguments[0] : undefined;\n\n        if (started) {\n            done({ code: _constants.errorCodes.ROUTER_ALREADY_STARTED });\n            return router;\n        }\n\n        var startPath = void 0,\n            startState = void 0;\n\n        started = true;\n        router.invokeEventListeners(_constants2.default.ROUTER_START);\n\n        // callback\n        var cb = function cb(err, state) {\n            var invokeErrCb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (!err) router.invokeEventListeners(_constants2.default.TRANSITION_SUCCESS, state, null, { replace: true });\n            if (err && invokeErrCb) router.invokeEventListeners(_constants2.default.TRANSITION_ERROR, state, null, err);\n            done(err, state);\n        };\n\n        if (startPathOrState === undefined && !options.defaultRoute) {\n            return cb({ code: _constants.errorCodes.NO_START_PATH_OR_STATE });\n        }if (typeof startPathOrState === 'string') {\n            startPath = startPathOrState;\n        } else if ((typeof startPathOrState === 'undefined' ? 'undefined' : _typeof(startPathOrState)) === 'object') {\n            startState = startPathOrState;\n        }\n\n        if (!startState) {\n            // If no supplied start state, get start state\n            startState = startPath === undefined ? null : router.matchPath(startPath);\n\n            // Navigate to default function\n            var navigateToDefault = function navigateToDefault() {\n                return router.navigateToDefault({ replace: true }, done);\n            };\n            var redirect = function redirect(route) {\n                return router.navigate(route.name, route.params, { replace: true, reload: true }, done);\n            };\n            // If matched start path\n            if (startState) {\n                router.transitionToState(startState, router.getState(), {}, function (err, state) {\n                    if (!err) cb(null, state);else if (err.redirect) redirect(err.redirect);else if (options.defaultRoute) navigateToDefault();else cb(err, null, false);\n                });\n            } else if (options.defaultRoute) {\n                // If default, navigate to default\n                navigateToDefault();\n            } else if (options.allowNotFound) {\n                cb(null, router.makeNotFoundState(startPath));\n            } else {\n                // No start match, no default => do nothing\n                cb({ code: _constants.errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);\n            }\n        } else {\n            // Initialise router with provided start state\n            router.setState(startState);\n            cb(null, startState);\n        }\n\n        return router;\n    }\n\n    /**\n     * Stop the router\n     * @return {Object} The router instance\n     */\n    function stop() {\n        if (started) {\n            router.setState(null);\n            started = false;\n            router.invokeEventListeners(_constants2.default.ROUTER_STOP);\n        }\n\n        return router;\n    }\n}\n  })();\n});","\nrequire.register(\"router5/core/utils.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withUtils;\n\nvar _constants = require('../constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction withUtils(router) {\n    var options = router.getOptions();\n\n    router.isActive = isActive;\n    router.areStatesEqual = areStatesEqual;\n    router.areStatesDescendants = areStatesDescendants;\n    router.buildPath = buildPath;\n    router.buildState = buildState;\n    router.matchPath = matchPath;\n    router.setRootPath = setRootPath;\n\n    /**\n     * Check if a route is currently active\n     * @param  {String}  name                     The route name\n     * @param  {Object}  params                   The route params\n     * @param  {Boolean} [strictEquality=false]   Whether to check if the given route is the active route, or part of the active route\n     * @param  {Boolean} [ignoreQueryParams=true] Whether to ignore query parameters\n     * @return {Boolean}                          Whether the given route is active\n     */\n    function isActive(name) {\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var strictEquality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var ignoreQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n        var activeState = router.getState();\n\n        if (!activeState) return false;\n\n        if (strictEquality || activeState.name === name) {\n            return areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);\n        }\n\n        return areStatesDescendants(router.makeState(name, params), activeState);\n    }\n\n    /**\n     * Compare two route state objects\n     * @param  {Object}  state1            The route state\n     * @param  {Object}  state2            The other route state\n     * @param  {Boolean} ignoreQueryParams Whether to ignore query parameters or not\n     * @return {Boolean}                   Whether the two route state are equal or not\n     */\n    function areStatesEqual(state1, state2) {\n        var ignoreQueryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        if (state1.name !== state2.name) return false;\n\n        var getUrlParams = function getUrlParams(name) {\n            return router.rootNode.getSegmentsByName(name).map(function (segment) {\n                return segment.parser[ignoreQueryParams ? 'urlParams' : 'params'];\n            }).reduce(function (params, p) {\n                return params.concat(p);\n            }, []);\n        };\n\n        var state1Params = getUrlParams(state1.name);\n        var state2Params = getUrlParams(state2.name);\n\n        return state1Params.length === state2Params.length && state1Params.every(function (p) {\n            return state1.params[p] === state2.params[p];\n        });\n    }\n\n    /**\n     * Check if two states are related\n     * @param  {State} parentState  The parent state\n     * @param  {State} childState   The child state\n     * @return {Boolean}            Whether the two states are descendants or not\n     */\n    function areStatesDescendants(parentState, childState) {\n        var regex = new RegExp('^' + parentState.name + '\\\\.(.*)$');\n        if (!regex.test(childState.name)) return false;\n        // If child state name extends parent state name, and all parent state params\n        // are in child state params.\n        return Object.keys(parentState.params).every(function (p) {\n            return parentState.params[p] === childState.params[p];\n        });\n    }\n\n    /**\n     * Build a path\n     * @param  {String} route  The route name\n     * @param  {Object} params The route params\n     * @return {String}        The path\n     */\n    function buildPath(route, params) {\n        if (route === _constants2.default.UNKNOWN_ROUTE) {\n            return params.path;\n        }\n\n        var useTrailingSlash = options.useTrailingSlash,\n            strictQueryParams = options.strictQueryParams;\n\n        return router.rootNode.buildPath(route, params, { trailingSlash: useTrailingSlash, strictQueryParams: strictQueryParams });\n    }\n\n    function buildState(route, params) {\n        return router.rootNode.buildState(route, params);\n    }\n\n    /**\n     * Match a path\n     * @param  {String} path     The path to match\n     * @param  {String} [source] The source (optional, used internally)\n     * @return {Object}          The matched state (null if unmatched)\n     */\n    function matchPath(path, source) {\n        var trailingSlash = options.trailingSlash,\n            strictQueryParams = options.strictQueryParams,\n            strongMatching = options.strongMatching;\n\n        var match = router.rootNode.matchPath(path, { trailingSlash: trailingSlash, strictQueryParams: strictQueryParams, strongMatching: strongMatching });\n\n        if (match) {\n            var name = match.name,\n                params = match.params,\n                _meta = match._meta;\n\n            var builtPath = options.useTrailingSlash === undefined ? path : router.buildPath(name, params);\n\n            return router.makeState(name, params, builtPath, _meta, source);\n        }\n\n        return null;\n    }\n\n    /**\n     * Set the root node patch, use carefully. It can be used to set app-wide allowed query parameters.\n     * @param {String} rootPath The root node path\n     */\n    function setRootPath(rootPath) {\n        router.rootNode.setPath(rootPath);\n    }\n}\n  })();\n});","\nrequire.register(\"router5/create-router.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _routeNode = require('route-node');\n\nvar _routeNode2 = _interopRequireDefault(_routeNode);\n\nvar _utils = require('./core/utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _routerLifecycle = require('./core/router-lifecycle');\n\nvar _routerLifecycle2 = _interopRequireDefault(_routerLifecycle);\n\nvar _navigation = require('./core/navigation');\n\nvar _navigation2 = _interopRequireDefault(_navigation);\n\nvar _middleware = require('./core/middleware');\n\nvar _middleware2 = _interopRequireDefault(_middleware);\n\nvar _plugins = require('./core/plugins');\n\nvar _plugins2 = _interopRequireDefault(_plugins);\n\nvar _routeLifecycle = require('./core/route-lifecycle');\n\nvar _routeLifecycle2 = _interopRequireDefault(_routeLifecycle);\n\nvar _clone = require('./core/clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _constants = require('./constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar defaultOptions = {\n    trailingSlash: 0,\n    useTrailingSlash: undefined,\n    autoCleanUp: true,\n    strictQueryParams: true,\n    allowNotFound: false,\n    strongMatching: true\n};\n\n/**\n * Create a router\n * @param  {Array}  [routes]          The routes\n * @param  {Object} [options={}]      The router options\n * @param  {Object} [dependencies={}] The router dependencies\n * @return {Object}                   The router instance\n */\nfunction createRouter(routes) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var deps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var routerState = null;\n    var stateId = 0;\n    var callbacks = {};\n    var dependencies = deps;\n    var options = _extends({}, defaultOptions);\n\n    Object.keys(opts).forEach(function (opt) {\n        return setOption(opt, opts[opt]);\n    });\n\n    var router = {\n        rootNode: rootNode,\n        getOptions: getOptions,\n        setOption: setOption,\n        getState: getState,\n        setState: setState,\n        makeState: makeState,\n        makeNotFoundState: makeNotFoundState,\n        setDependency: setDependency,\n        setDependencies: setDependencies,\n        getDependencies: getDependencies,\n        add: add,\n        addNode: addNode,\n        executeFactory: executeFactory,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        invokeEventListeners: invokeEventListeners\n    };\n\n    /**\n     * Invoke all event listeners by event name. Possible event names are listed under constants\n     * (`import { constants } from 'router5'`): `ROUTER_START`, `ROUTER_STOP`, `TRANSITION_START`,\n     * `TRANSITION_CANCEL`, `TRANSITION_SUCCESS`, `TRANSITION_ERROR`.\n     * This method is used internally and should not be invoked directly, but it can be useful for\n     * testing purposes.\n     * @private\n     * @name invokeEventListeners\n     * @param  {String}    eventName The event name\n     */\n    function invokeEventListeners(eventName) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n        }\n\n        (callbacks[eventName] || []).forEach(function (cb) {\n            return cb.apply(undefined, args);\n        });\n    }\n\n    /**\n     * Removes an event listener\n     * @private\n     * @param  {String}   eventName The event name\n     * @param  {Function} cb        The callback to remove\n     */\n    function removeEventListener(eventName, cb) {\n        callbacks[eventName] = callbacks[eventName].filter(function (_cb) {\n            return _cb !== cb;\n        });\n    }\n\n    /**\n     * Add an event listener\n     * @private\n     * @param {String}   eventName The event name\n     * @param {Function} cb        The callback to add\n     */\n    function addEventListener(eventName, cb) {\n        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);\n\n        return function () {\n            return removeEventListener(eventName, cb);\n        };\n    }\n\n    (0, _utils2.default)(router);\n    (0, _plugins2.default)(router);\n    (0, _middleware2.default)(router);\n    (0, _routeLifecycle2.default)(router);\n    (0, _routerLifecycle2.default)(router);\n    (0, _navigation2.default)(router);\n    (0, _clone2.default)(router, createRouter);\n\n    var rootNode = routes instanceof _routeNode2.default ? routes : new _routeNode2.default('', '', routes, addCanActivate);\n\n    router.rootNode = rootNode;\n\n    return router;\n\n    function addCanActivate(route) {\n        if (route.canActivate) router.canActivate(route.name, route.canActivate);\n    }\n\n    /**\n     * Build a state object\n     * @param  {String} name         The state name\n     * @param  {Object} params       The state params\n     * @param  {String} path         The state path\n     * @param  {Object} [metaParams] Description of the state params\n     * @param  {String} [source]     The source of the routing state\n     * @return {Object}              The state object\n     */\n    function makeState(name, params, path, metaParams, source) {\n        var state = {};\n        var setProp = function setProp(key, value) {\n            return Object.defineProperty(state, key, { value: value, enumerable: true });\n        };\n        setProp('name', name);\n        setProp('params', params);\n        setProp('path', path);\n\n        if (metaParams || source) {\n            stateId += 1;\n            var meta = { params: metaParams, id: stateId };\n\n            if (source) meta.source = source;\n\n            setProp('meta', meta);\n        }\n\n        return state;\n    }\n\n    /**\n     * Build a not found state for a given path\n     * @param  {String} path The unmatched path\n     * @return {Object}      The not found state object\n     */\n    function makeNotFoundState(path) {\n        return makeState(_constants2.default.UNKNOWN_ROUTE, { path: path }, path, {});\n    }\n\n    /**\n     * Get the current router state\n     * @return {Object} The current state\n     */\n    function getState() {\n        return routerState;\n    }\n\n    /**\n     * Set the current router state\n     * @param {Object} state The state object\n     */\n    function setState(state) {\n        routerState = state;\n    }\n\n    /**\n     * Get router options\n     * @return {Object} The router options\n     */\n    function getOptions() {\n        return options;\n    }\n\n    /**\n     * Set an option\n     * @param  {String} option The option name\n     * @param  {*}      value  The option value\n     * @return {Object}       The router instance\n     */\n    function setOption(option, value) {\n        if (option === 'useTrailingSlash' && value !== undefined) {\n            options.trailingSlash = true;\n        }\n        options[option] = value;\n        return router;\n    }\n\n    /**\n     * Set a router dependency\n     * @param  {String} dependencyName The dependency name\n     * @param  {*}      dependency     The dependency\n     * @return {Object}                The router instance\n     */\n    function setDependency(dependencyName, dependency) {\n        dependencies[dependencyName] = dependency;\n        return router;\n    }\n\n    /**\n     * Add dependencies\n     * @param { Object} deps A object of dependencies (key-value pairs)\n     * @return {Object}      The router instance\n     */\n    function setDependencies(deps) {\n        Object.keys(deps).forEach(function (depName) {\n            dependencies[depName] = deps[depName];\n        });\n\n        return router;\n    }\n\n    /**\n     * Get dependencies\n     * @return {Object} The dependencies\n     */\n    function getDependencies() {\n        return dependencies;\n    }\n\n    function getInjectables() {\n        return [router, getDependencies()];\n    }\n\n    function executeFactory(factoryFunction) {\n        return factoryFunction.apply(undefined, _toConsumableArray(getInjectables()));\n    }\n\n    /**\n     * Add routes\n     * @param  {Array} routes A list of routes to add\n     * @return {Object}       The router instance\n     */\n    function add(routes) {\n        rootNode.add(routes, addCanActivate);\n        return router;\n    }\n\n    /**\n     * Add a single route (node)\n     * @param {String} name                   The route name (full name)\n     * @param {String} path                   The route path (from parent)\n     * @param {Function} [canActivateHandler] The canActivate handler for this node\n     */\n    function addNode(name, path, canActivateHandler) {\n        router.rootNode.addNode(name, path);\n        if (canActivateHandler) router.canActivate(name, canActivateHandler);\n        return router;\n    }\n}\n\nexports.default = createRouter;\n  })();\n});","\nrequire.register(\"router5/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.constants = exports.transitionPath = exports.errorCodes = exports.loggerPlugin = exports.RouteNode = exports.createRouter = undefined;\n\nvar _createRouter = require('./create-router');\n\nvar _createRouter2 = _interopRequireDefault(_createRouter);\n\nvar _routeNode = require('route-node');\n\nvar _routeNode2 = _interopRequireDefault(_routeNode);\n\nvar _logger = require('./plugins/logger');\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _router = require('router5.transition-path');\n\nvar _router2 = _interopRequireDefault(_router);\n\nvar _constants = require('./constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _createRouter2.default;\nexports.createRouter = _createRouter2.default;\nexports.RouteNode = _routeNode2.default;\nexports.loggerPlugin = _logger2.default;\nexports.errorCodes = _constants.errorCodes;\nexports.transitionPath = _router2.default;\nexports.constants = _constants2.default;\n  })();\n});","\nrequire.register(\"router5/plugins/browser/browser.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n * Dumb functions\n */\n// istanbul ignore next\nvar identity = function identity(arg) {\n    return function () {\n        return arg;\n    };\n};\n// istanbul ignore next\nvar noop = function noop() {};\n\n/**\n * Browser detection\n */\nvar isBrowser = typeof window !== 'undefined' && window.history;\n\n/**\n * Browser functions needed by router5\n */\nvar getBase = function getBase() {\n    return window.location.pathname.replace(/\\/$/, '');\n};\n\nvar pushState = function pushState(state, title, path) {\n    return window.history.pushState(state, title, path);\n};\n\nvar replaceState = function replaceState(state, title, path) {\n    return window.history.replaceState(state, title, path);\n};\n\nvar addPopstateListener = function addPopstateListener(fn) {\n    return window.addEventListener('popstate', fn);\n};\n\nvar removePopstateListener = function removePopstateListener(fn) {\n    return window.removeEventListener('popstate', fn);\n};\n\nvar getLocation = function getLocation(opts) {\n    var path = opts.useHash ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '') : window.location.pathname.replace(new RegExp('^' + opts.base), '');\n    return (path || '/') + window.location.search;\n};\n\nvar getState = function getState() {\n    return window.history.state;\n};\n\n/**\n * Export browser object\n */\nvar browser = {};\nif (isBrowser) {\n    browser = { getBase: getBase, pushState: pushState, replaceState: replaceState, addPopstateListener: addPopstateListener, removePopstateListener: removePopstateListener, getLocation: getLocation, getState: getState };\n} else {\n    // istanbul ignore next\n    browser = {\n        getBase: identity(''),\n        pushState: noop,\n        replaceState: noop,\n        addPopstateListener: noop,\n        removePopstateListener: noop,\n        getLocation: identity(''),\n        getState: identity(null)\n    };\n}\n\nexports.default = browser;\n  })();\n});","\nrequire.register(\"router5/plugins/browser/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _constants = require('../../constants');\n\nvar _constants2 = _interopRequireDefault(_constants);\n\nvar _browser = require('./browser');\n\nvar _browser2 = _interopRequireDefault(_browser);\n\nvar _utils = require('./utils');\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultOptions = {\n    forceDeactivate: true,\n    useHash: false,\n    hashPrefix: '',\n    base: false\n};\n\nvar source = 'popstate';\n\nfunction browserPluginFactory() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var browser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _browser2.default;\n\n    var options = _extends({}, defaultOptions, opts);\n    var transitionOptions = { forceDeactivate: options.forceDeactivate, source: source };\n\n    function browserPlugin(router) {\n        var routerOptions = router.getOptions();\n        var routerStart = router.start;\n\n        (0, _utils2.default)(router, options);\n\n        router.start = function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            if (args.length === 0 || typeof args[0] === 'function') {\n                routerStart.apply(undefined, [browser.getLocation(options)].concat(args));\n            } else {\n                routerStart.apply(undefined, args);\n            }\n\n            return router;\n        };\n\n        router.replaceHistoryState = function (name) {\n            var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var state = router.buildState(name, params);\n            var url = router.buildUrl(name, params);\n            router.lastKnownState = state;\n            browser.replaceState(state, '', url);\n        };\n\n        function updateBrowserState(state, url, replace) {\n            if (replace) browser.replaceState(state, '', url);else browser.pushState(state, '', url);\n        }\n\n        function onPopState(evt) {\n            var routerState = router.getState();\n            // Do nothing if no state or if last know state is poped state (it should never happen)\n            var newState = !evt.state || !evt.state.name;\n            var state = newState ? router.matchPath(browser.getLocation(options), source) : evt.state;\n            var defaultRoute = routerOptions.defaultRoute,\n                defaultParams = routerOptions.defaultParams;\n\n\n            if (!state) {\n                // If current state is already the default route, we will have a double entry\n                // Navigating back and forth will emit SAME_STATES error\n                defaultRoute && router.navigateToDefault(_extends({}, transitionOptions, { reload: true, replace: true }));\n                return;\n            }\n            if (routerState && router.areStatesEqual(state, routerState, false)) {\n                return;\n            }\n\n            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {\n                if (err) {\n                    if (err.redirect) {\n                        var _err$redirect = err.redirect,\n                            name = _err$redirect.name,\n                            params = _err$redirect.params;\n\n\n                        router.navigate(name, params, _extends({}, transitionOptions, { replace: true }));\n                    } else if (err === _constants.errorCodes.CANNOT_DEACTIVATE) {\n                        var url = router.buildUrl(routerState.name, routerState.params);\n                        if (!newState) {\n                            // Keep history state unchanged but use current URL\n                            updateBrowserState(state, url, true);\n                        }\n                        // else do nothing or history will be messed up\n                        // TODO: history.back()?\n                    } else {\n                        // Force navigation to default state\n                        defaultRoute && router.navigate(defaultRoute, defaultParams, _extends({}, transitionOptions, { reload: true, replace: true }));\n                    }\n                } else {\n                    router.invokeEventListeners(_constants2.default.TRANSITION_SUCCESS, toState, routerState, { replace: true });\n                }\n            });\n        }\n\n        function onStart() {\n            if (options.useHash && !options.base) {\n                // Guess base\n                options.base = browser.getBase();\n            }\n\n            browser.addPopstateListener(onPopState);\n        }\n\n        function onStop() {\n            browser.removePopstateListener(onPopState);\n        }\n\n        function onTransitionSuccess(toState, fromState, opts) {\n            var historyState = browser.getState();\n            var replace = opts.replace || fromState && router.areStatesEqual(toState, fromState, false) || opts.reload && historyState && router.areStatesEqual(toState, historyState, false);\n            updateBrowserState(toState, router.buildUrl(toState.name, toState.params), replace);\n        }\n\n        return { onStart: onStart, onStop: onStop, onTransitionSuccess: onTransitionSuccess, onPopState: onPopState };\n    };\n\n    browserPlugin.pluginName = 'BROWSER_PLUGIN';\n\n    return browserPlugin;\n}\n\nexports.default = browserPluginFactory;\n  })();\n});","\nrequire.register(\"router5/plugins/browser/utils.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = withUtils;\nfunction withUtils(router, options) {\n    router.urlToPath = urlToPath;\n    router.buildUrl = buildUrl;\n    router.matchUrl = matchUrl;\n\n    function buildUrl(route, params) {\n        var base = options.base || '';\n        var prefix = options.useHash ? '#' + options.hashPrefix : '';\n        var path = router.buildPath(route, params);\n\n        return base + prefix + path;\n    }\n\n    function urlToPath(url) {\n        var match = url.match(/^(?:http|https)\\:\\/\\/(?:[0-9a-z_\\-\\.\\:]+?)(?=\\/)(.*)$/);\n        var path = match ? match[1] : url;\n\n        var pathParts = path.match(/^(.+?)(#.+?)?(\\?.+)?$/);\n\n        if (!pathParts) throw new Error('[router5] Could not parse url ' + url);\n\n        var pathname = pathParts[1];\n        var hash = pathParts[2] || '';\n        var search = pathParts[3] || '';\n\n        return (options.useHash ? hash.replace(new RegExp('^#' + options.hashPrefix), '') : options.base ? pathname.replace(new RegExp('^' + options.base), '') : pathname) + search;\n    }\n\n    function matchUrl(url) {\n        return router.matchPath(urlToPath(url));\n    }\n}\n  })();\n});","\nrequire.register(\"router5/plugins/listeners/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _router = require('router5.transition-path');\n\nvar _router2 = _interopRequireDefault(_router);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar defaultOptions = {\n    autoCleanUp: true\n};\n\nfunction listenersPluginFactory() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOptions;\n\n    function listenersPlugin(router) {\n        var listeners = {};\n\n        function removeListener(name, cb) {\n            if (cb) {\n                if (listeners[name]) listeners[name] = listeners[name].filter(function (callback) {\n                    return callback !== cb;\n                });\n            } else {\n                listeners[name] = [];\n            }\n            return router;\n        };\n\n        function addListener(name, cb, replace) {\n            var normalizedName = name.replace(/^(\\*|\\^|=)/, '');\n\n            if (normalizedName && !/^\\$/.test(name)) {\n                var segments = router.rootNode.getSegmentsByName(normalizedName);\n                if (!segments) console.warn('No route found for ' + normalizedName + ', listener might never be called!');\n            }\n\n            if (!listeners[name]) listeners[name] = [];\n            listeners[name] = (replace ? [] : listeners[name]).concat(cb);\n\n            return router;\n        };\n\n        router.getListeners = function () {\n            return listeners;\n        };\n\n        router.addListener = function (cb) {\n            return addListener('*', cb);\n        };\n        router.removeListener = function (cb) {\n            return removeListener('*', cb);\n        };\n\n        router.addNodeListener = function (name, cb) {\n            return addListener('^' + name, cb, true);\n        };\n        router.removeNodeListener = function (name, cb) {\n            return removeListener('^' + name, cb);\n        };\n\n        router.addRouteListener = function (name, cb) {\n            return addListener('=' + name, cb);\n        };\n        router.removeRouteListener = function (name, cb) {\n            return removeListener('=' + name, cb);\n        };\n\n        function invokeListeners(name, toState, fromState) {\n            (listeners[name] || []).forEach(function (cb) {\n                if (listeners[name].indexOf(cb) !== -1) {\n                    cb(toState, fromState);\n                }\n            });\n        }\n\n        function onTransitionSuccess(toState, fromState, opts) {\n            var _transitionPath = (0, _router2.default)(toState, fromState),\n                intersection = _transitionPath.intersection,\n                toDeactivate = _transitionPath.toDeactivate;\n\n            var intersectionNode = opts.reload ? '' : intersection;\n            var name = toState.name;\n\n\n            if (options.autoCleanUp) {\n                toDeactivate.forEach(function (name) {\n                    return removeListener('^' + name);\n                });\n            }\n\n            invokeListeners('^' + intersectionNode, toState, fromState);\n            invokeListeners('=' + name, toState, fromState);\n            invokeListeners('*', toState, fromState);\n        }\n\n        return { onTransitionSuccess: onTransitionSuccess };\n    };\n\n    listenersPlugin.pluginName = 'LISTENERS_PLUGIN';\n\n    return listenersPlugin;\n}\n\nexports.default = listenersPluginFactory;\n  })();\n});","\nrequire.register(\"router5/plugins/logger/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/* istanbul ignore next */\n/*eslint no-console: 0*/\n\nfunction loggerPlugin() {\n    var startGroup = function startGroup() {\n        return console.group('Router transition');\n    };\n    var endGroup = function endGroup() {\n        return console.groupEnd('Router transition');\n    };\n\n    console.info('Router started');\n\n    return {\n        onStop: function onStop() {\n            console.info('Router stopped');\n        },\n        onTransitionStart: function onTransitionStart(toState, fromState) {\n            endGroup();\n            startGroup();\n            console.log('Transition started from state');\n            console.log(fromState);\n            console.log('To state');\n            console.log(toState);\n        },\n        onTransitionCancel: function onTransitionCancel() {\n            console.warn('Transition cancelled');\n        },\n        onTransitionError: function onTransitionError(toState, fromState, err) {\n            console.warn('Transition error with code ' + err.code);\n            endGroup();\n        },\n        onTransitionSuccess: function onTransitionSuccess() {\n            console.log('Transition success');\n            endGroup();\n        }\n    };\n};\n\nloggerPlugin.pluginName = 'LOGGER_PLUGIN';\n\nexports.default = loggerPlugin;\n  })();\n});","\nrequire.register(\"router5/transition/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _router = require('router5.transition-path');\n\nvar _router2 = _interopRequireDefault(_router);\n\nvar _resolve = require('./resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _constants = require('../constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexports.default = transition;\n\n\nfunction transition(router, toState, fromState, opts, callback) {\n    var cancelled = false;\n    var completed = false;\n    var options = router.getOptions();\n\n    var _router$getLifecycleF = router.getLifecycleFunctions(),\n        _router$getLifecycleF2 = _slicedToArray(_router$getLifecycleF, 2),\n        canDeactivateFunctions = _router$getLifecycleF2[0],\n        canActivateFunctions = _router$getLifecycleF2[1];\n\n    var middlewareFunctions = router.getMiddlewareFunctions();\n    var isCancelled = function isCancelled() {\n        return cancelled;\n    };\n    var cancel = function cancel() {\n        if (!cancelled && !completed) {\n            cancelled = true;\n            callback({ code: _constants.errorCodes.TRANSITION_CANCELLED }, null);\n        }\n    };\n    var done = function done(err, state) {\n        completed = true;\n\n        if (isCancelled()) {\n            return;\n        }\n\n        if (!err && options.autoCleanUp) {\n            var activeSegments = (0, _router.nameToIDs)(toState.name);\n            Object.keys(canDeactivateFunctions).forEach(function (name) {\n                if (activeSegments.indexOf(name) === -1) router.clearCanDeactivate(name);\n            });\n        }\n\n        callback(err, state || toState);\n    };\n    var makeError = function makeError(base, err) {\n        return _extends({}, base, err instanceof Object ? err : { error: err });\n    };\n\n    var _transitionPath = (0, _router2.default)(toState, fromState),\n        toDeactivate = _transitionPath.toDeactivate,\n        toActivate = _transitionPath.toActivate;\n\n    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };\n\n    var canDeactivate = function canDeactivate(toState, fromState, cb) {\n        var canDeactivateFunctionMap = toDeactivate.filter(function (name) {\n            return canDeactivateFunctions[name];\n        }).reduce(function (fnMap, name) {\n            return _extends({}, fnMap, _defineProperty({}, name, canDeactivateFunctions[name]));\n        }, {});\n\n        (0, _resolve2.default)(canDeactivateFunctionMap, _extends({}, asyncBase, { errorKey: 'segment' }), function (err) {\n            return cb(err ? makeError({ code: _constants.errorCodes.CANNOT_DEACTIVATE }, err) : null);\n        });\n    };\n\n    var canActivate = function canActivate(toState, fromState, cb) {\n        var canActivateFunctionMap = toActivate.filter(function (name) {\n            return canActivateFunctions[name];\n        }).reduce(function (fnMap, name) {\n            return _extends({}, fnMap, _defineProperty({}, name, canActivateFunctions[name]));\n        }, {});\n\n        (0, _resolve2.default)(canActivateFunctionMap, _extends({}, asyncBase, { errorKey: 'segment' }), function (err) {\n            return cb(err ? makeError({ code: _constants.errorCodes.CANNOT_ACTIVATE }, err) : null);\n        });\n    };\n\n    var middleware = !middlewareFunctions.length ? [] : function (toState, fromState, cb) {\n        return (0, _resolve2.default)(middlewareFunctions, _extends({}, asyncBase), function (err, state) {\n            return cb(err ? makeError({ code: _constants.errorCodes.TRANSITION_ERR }, err) : null, state || toState);\n        });\n    };\n\n    var pipeline = (fromState && !opts.forceDeactivate ? [canDeactivate] : []).concat(canActivate).concat(middleware);\n\n    (0, _resolve2.default)(pipeline, asyncBase, done);\n\n    return cancel;\n}\n  })();\n});","\nrequire.register(\"router5/transition/resolve.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"router5\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = resolve;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction resolve(functions, _ref, callback) {\n    var isCancelled = _ref.isCancelled,\n        toState = _ref.toState,\n        fromState = _ref.fromState,\n        errorKey = _ref.errorKey;\n\n    var remainingFunctions = Array.isArray(functions) ? functions : Object.keys(functions);\n\n    var isState = function isState(obj) {\n        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj.name !== undefined && obj.params !== undefined && obj.path !== undefined;\n    };\n    var hasStateChanged = function hasStateChanged(state) {\n        return state.name !== toState.name || state.params !== toState.params || state.path !== toState.path;\n    };\n\n    var processFn = function processFn(done) {\n        if (!remainingFunctions.length) return true;\n\n        var isMapped = typeof remainingFunctions[0] === 'string';\n        var errBase = errorKey && isMapped ? _defineProperty({}, errorKey, remainingFunctions[0]) : {};\n        var stepFn = isMapped ? functions[remainingFunctions[0]] : remainingFunctions[0];\n\n        // const len = stepFn.length;\n        var res = stepFn.call(null, toState, fromState, done);\n        if (isCancelled()) {\n            done(null);\n        } else if (typeof res === 'boolean') {\n            done(res ? null : errBase);\n        } else if (res && typeof res.then === 'function') {\n            res.then(function (resVal) {\n                if (resVal instanceof Error) done({ error: resVal }, null);else done(null, resVal);\n            }, function (err) {\n                if (err instanceof Error) {\n                    console.error(err.stack || err);\n                    done(_extends({}, errBase, { promiseError: err }), null);\n                } else {\n                    done((typeof err === 'undefined' ? 'undefined' : _typeof(err)) === 'object' ? _extends({}, errBase, err) : errBase, null);\n                }\n            });\n        }\n        // else: wait for done to be called\n\n        return false;\n    };\n\n    var iterate = function iterate(err, val) {\n        if (isCancelled()) {\n            callback();\n        } else if (err) {\n            callback(err);\n        } else {\n            if (val && isState(val)) {\n                if (hasStateChanged(val)) console.error('[router5][transition] Warning: state values changed during transition process.');\n                toState = val;\n            }\n            remainingFunctions = remainingFunctions.slice(1);\n            next();\n        }\n    };\n\n    var next = function next() {\n        if (isCancelled()) {\n            callback();\n        } else {\n            var finished = processFn(iterate);\n            if (finished) callback(null, toState);\n        }\n    };\n\n    next();\n}\n  })();\n});","\nrequire.register(\"rxjs/BehaviorSubject.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('./Subject');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\n/**\n * @class BehaviorSubject<T>\n */\nvar BehaviorSubject = (function (_super) {\n    __extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        _super.call(this);\n        this._value = _value;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject_1.Subject));\nexports.BehaviorSubject = BehaviorSubject;\n//# sourceMappingURL=BehaviorSubject.js.map\n  })();\n});","\nrequire.register(\"rxjs/InnerSubscriber.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar InnerSubscriber = (function (_super) {\n    __extends(InnerSubscriber, _super);\n    function InnerSubscriber(parent, outerValue, outerIndex) {\n        _super.call(this);\n        this.parent = parent;\n        this.outerValue = outerValue;\n        this.outerIndex = outerIndex;\n        this.index = 0;\n    }\n    InnerSubscriber.prototype._next = function (value) {\n        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n    };\n    InnerSubscriber.prototype._error = function (error) {\n        this.parent.notifyError(error, this);\n        this.unsubscribe();\n    };\n    InnerSubscriber.prototype._complete = function () {\n        this.parent.notifyComplete(this);\n        this.unsubscribe();\n    };\n    return InnerSubscriber;\n}(Subscriber_1.Subscriber));\nexports.InnerSubscriber = InnerSubscriber;\n//# sourceMappingURL=InnerSubscriber.js.map\n  })();\n});","\nrequire.register(\"rxjs/Observable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar root_1 = require('./util/root');\nvar toSubscriber_1 = require('./util/toSubscriber');\nvar observable_1 = require('./symbol/observable');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is  called when the Observable is\n     * initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or\n     * `complete` can be called to notify of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * Creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @return {Observable} a new observable with the Operator applied\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            operator.call(sink, this.source);\n        }\n        else {\n            sink.add(this._trySubscribe(sink));\n        }\n        if (sink.syncErrorThrowable) {\n            sink.syncErrorThrowable = false;\n            if (sink.syncErrorThrown) {\n                throw sink.syncErrorValue;\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.syncErrorThrown = true;\n            sink.syncErrorValue = err;\n            sink.error(err);\n        }\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @return {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, PromiseCtor) {\n        var _this = this;\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        return new PromiseCtor(function (resolve, reject) {\n            var subscription = _this.subscribe(function (value) {\n                if (subscription) {\n                    // if there is a subscription, then we can surmise\n                    // the next handling is asynchronous. Any errors thrown\n                    // need to be rejected explicitly and unsubscribe must be\n                    // called manually\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscription.unsubscribe();\n                    }\n                }\n                else {\n                    // if there is NO subscription, then we're getting a nexted\n                    // value synchronously during subscription. We can just call it.\n                    // If it errors, Observable's `subscribe` will ensure the\n                    // unsubscription logic is called, then synchronously rethrow the error.\n                    // After that, Promise will trap the error and send it\n                    // down the rejection path.\n                    next(value);\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     * @method Symbol.observable\n     * @return {Observable} this instance of the observable\n     */\n    Observable.prototype[observable_1.$$observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * Creates a new cold Observable by calling the Observable constructor\n     * @static true\n     * @owner Observable\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @return {Observable} a new cold observable\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n  })();\n});","\nrequire.register(\"rxjs/Observer.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nexports.empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n  })();\n});","\nrequire.register(\"rxjs/OuterSubscriber.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('./Subscriber');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar OuterSubscriber = (function (_super) {\n    __extends(OuterSubscriber, _super);\n    function OuterSubscriber() {\n        _super.apply(this, arguments);\n    }\n    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n        this.destination.error(error);\n    };\n    OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.destination.complete();\n    };\n    return OuterSubscriber;\n}(Subscriber_1.Subscriber));\nexports.OuterSubscriber = OuterSubscriber;\n//# sourceMappingURL=OuterSubscriber.js.map\n  })();\n});","\nrequire.register(\"rxjs/Subject.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('./Observable');\nvar Subscriber_1 = require('./Subscriber');\nvar Subscription_1 = require('./Subscription');\nvar ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');\nvar SubjectSubscription_1 = require('./SubjectSubscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * @class SubjectSubscriber<T>\n */\nvar SubjectSubscriber = (function (_super) {\n    __extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        _super.call(this, destination);\n        this.destination = destination;\n    }\n    return SubjectSubscriber;\n}(Subscriber_1.Subscriber));\nexports.SubjectSubscriber = SubjectSubscriber;\n/**\n * @class Subject<T>\n */\nvar Subject = (function (_super) {\n    __extends(Subject, _super);\n    function Subject() {\n        _super.call(this);\n        this.observers = [];\n        this.closed = false;\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription_1.Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable_1.Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable_1.Observable));\nexports.Subject = Subject;\n/**\n * @class AnonymousSubject<T>\n */\nvar AnonymousSubject = (function (_super) {\n    __extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        _super.call(this);\n        this.destination = destination;\n        this.source = source;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription_1.Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexports.AnonymousSubject = AnonymousSubject;\n//# sourceMappingURL=Subject.js.map\n  })();\n});","\nrequire.register(\"rxjs/SubjectSubscription.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscription_1 = require('./Subscription');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SubjectSubscription = (function (_super) {\n    __extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        _super.call(this);\n        this.subject = subject;\n        this.subscriber = subscriber;\n        this.closed = false;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription_1.Subscription));\nexports.SubjectSubscription = SubjectSubscription;\n//# sourceMappingURL=SubjectSubscription.js.map\n  })();\n});","\nrequire.register(\"rxjs/Subscriber.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription_1 = require('./Subscription');\nvar Observer_1 = require('./Observer');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    /**\n     * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n     * defined Observer or a `next` callback function.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     */\n    function Subscriber(destinationOrNext, error, complete) {\n        _super.call(this);\n        this.syncErrorValue = null;\n        this.syncErrorThrown = false;\n        this.syncErrorThrowable = false;\n        this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                this.destination = Observer_1.empty;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    this.destination = Observer_1.empty;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        this.destination = destinationOrNext;\n                        this.destination.add(this);\n                    }\n                    else {\n                        this.syncErrorThrowable = true;\n                        this.destination = new SafeSubscriber(this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                this.syncErrorThrowable = true;\n                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n                break;\n        }\n    }\n    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };\n    /**\n     * A static factory for a Subscriber, given a (potentially partial) definition\n     * of an Observer.\n     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n     * @param {function(e: ?any): void} [error] The `error` callback of an\n     * Observer.\n     * @param {function(): void} [complete] The `complete` callback of an\n     * Observer.\n     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n     * Observer represented by the given arguments.\n     */\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `next` from\n     * the Observable, with a value. The Observable may call this method 0 or more\n     * times.\n     * @param {T} [value] The `next` value.\n     * @return {void}\n     */\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive notifications of type `error` from\n     * the Observable, with an attached {@link Error}. Notifies the Observer that\n     * the Observable has experienced an error condition.\n     * @param {any} [err] The `error` exception.\n     * @return {void}\n     */\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    /**\n     * The {@link Observer} callback to receive a valueless notification of type\n     * `complete` from the Observable. Notifies the Observer that the Observable\n     * has finished sending push-based notifications.\n     * @return {void}\n     */\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        this._parent = null;\n        this._parents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parent = _parent;\n        this._parents = _parents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription_1.Subscription));\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        _super.call(this);\n        this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = this;\n        if (isFunction_1.isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            context = observerOrNext;\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (isFunction_1.isFunction(context.unsubscribe)) {\n                this.add(context.unsubscribe.bind(context));\n            }\n            context.unsubscribe = this.unsubscribe.bind(this);\n        }\n        this._context = context;\n        this._next = next;\n        this._error = error;\n        this._complete = complete;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._error) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                throw err;\n            }\n            else {\n                _parentSubscriber.syncErrorValue = err;\n                _parentSubscriber.syncErrorThrown = true;\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._complete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._complete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            throw err;\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            parent.syncErrorValue = err;\n            parent.syncErrorThrown = true;\n            return true;\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\n//# sourceMappingURL=Subscriber.js.map\n  })();\n});","\nrequire.register(\"rxjs/Subscription.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar tryCatch_1 = require('./util/tryCatch');\nvar errorObject_1 = require('./util/errorObject');\nvar UnsubscriptionError_1 = require('./util/UnsubscriptionError');\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nvar Subscription = (function () {\n    /**\n     * @param {function(): void} [unsubscribe] A function describing how to\n     * perform the disposal of resources when the `unsubscribe` method is called.\n     */\n    function Subscription(unsubscribe) {\n        /**\n         * A flag to indicate whether this Subscription has already been unsubscribed.\n         * @type {boolean}\n         */\n        this.closed = false;\n        this._parent = null;\n        this._parents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    /**\n     * Disposes the resources held by the subscription. May, for instance, cancel\n     * an ongoing Observable execution or cancel any other type of work that\n     * started when the Subscription was created.\n     * @return {void}\n     */\n    Subscription.prototype.unsubscribe = function () {\n        var hasErrors = false;\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parent = null;\n        this._parents = null;\n        // null out _subscriptions first so any child subscriptions that attempt\n        // to remove themselves from this subscription will noop\n        this._subscriptions = null;\n        var index = -1;\n        var len = _parents ? _parents.length : 0;\n        // if this._parent is null, then so is this._parents, and we\n        // don't have to remove ourselves from any parent subscriptions.\n        while (_parent) {\n            _parent.remove(this);\n            // if this._parents is null or index >= len,\n            // then _parent is set to null, and the loop exits\n            _parent = ++index < len && _parents[index] || null;\n        }\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n            if (trial === errorObject_1.errorObject) {\n                hasErrors = true;\n                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n            }\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            index = -1;\n            len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject_1.isObject(sub)) {\n                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                    if (trial === errorObject_1.errorObject) {\n                        hasErrors = true;\n                        errors = errors || [];\n                        var err = errorObject_1.errorObject.e;\n                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n        }\n        if (hasErrors) {\n            throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n        }\n    };\n    /**\n     * Adds a tear down to be called during the unsubscribe() of this\n     * Subscription.\n     *\n     * If the tear down being added is a subscription that is already\n     * unsubscribed, is the same reference `add` is being called on, or is\n     * `Subscription.EMPTY`, it will not be added.\n     *\n     * If this subscription is already in an `closed` state, the passed\n     * tear down logic will be executed immediately.\n     *\n     * @param {TeardownLogic} teardown The additional logic to execute on\n     * teardown.\n     * @return {Subscription} Returns the Subscription used or created to be\n     * added to the inner subscriptions list. This Subscription can be used with\n     * `remove()` to remove the passed teardown logic from the inner subscriptions\n     * list.\n     */\n    Subscription.prototype.add = function (teardown) {\n        if (!teardown || (teardown === Subscription.EMPTY)) {\n            return Subscription.EMPTY;\n        }\n        if (teardown === this) {\n            return this;\n        }\n        var subscription = teardown;\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default:\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n        var subscriptions = this._subscriptions || (this._subscriptions = []);\n        subscriptions.push(subscription);\n        subscription._addParent(this);\n        return subscription;\n    };\n    /**\n     * Removes a Subscription from the internal list of subscriptions that will\n     * unsubscribe during the unsubscribe process of this Subscription.\n     * @param {Subscription} subscription The subscription to remove.\n     * @return {void}\n     */\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.prototype._addParent = function (parent) {\n        var _a = this, _parent = _a._parent, _parents = _a._parents;\n        if (!_parent || _parent === parent) {\n            // If we don't have a parent, or the new parent is the same as the\n            // current parent, then set this._parent to the new parent.\n            this._parent = parent;\n        }\n        else if (!_parents) {\n            // If there's already one parent, but not multiple, allocate an Array to\n            // store the rest of the parent Subscriptions.\n            this._parents = [parent];\n        }\n        else if (_parents.indexOf(parent) === -1) {\n            // Only add the new parent to the _parents list if it's not already there.\n            _parents.push(parent);\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexports.Subscription = Subscription;\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/do.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar do_1 = require('../../operator/do');\nObservable_1.Observable.prototype.do = do_1._do;\nObservable_1.Observable.prototype._do = do_1._do;\n//# sourceMappingURL=do.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/map.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar map_1 = require('../../operator/map');\nObservable_1.Observable.prototype.map = map_1.map;\n//# sourceMappingURL=map.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/publishBehavior.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar publishBehavior_1 = require('../../operator/publishBehavior');\nObservable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/scan.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar scan_1 = require('../../operator/scan');\nObservable_1.Observable.prototype.scan = scan_1.scan;\n//# sourceMappingURL=scan.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/startWith.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar startWith_1 = require('../../operator/startWith');\nObservable_1.Observable.prototype.startWith = startWith_1.startWith;\n//# sourceMappingURL=startWith.js.map\n  })();\n});","\nrequire.register(\"rxjs/add/operator/switchMap.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../../Observable');\nvar switchMap_1 = require('../../operator/switchMap');\nObservable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n//# sourceMappingURL=switchMap.js.map\n  })();\n});","\nrequire.register(\"rxjs/observable/ArrayObservable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar ScalarObservable_1 = require('./ScalarObservable');\nvar EmptyObservable_1 = require('./EmptyObservable');\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ArrayObservable = (function (_super) {\n    __extends(ArrayObservable, _super);\n    function ArrayObservable(array, scheduler) {\n        _super.call(this);\n        this.array = array;\n        this.scheduler = scheduler;\n        if (!scheduler && array.length === 1) {\n            this._isScalar = true;\n            this.value = array[0];\n        }\n    }\n    ArrayObservable.create = function (array, scheduler) {\n        return new ArrayObservable(array, scheduler);\n    };\n    /**\n     * Creates an Observable that emits some values you specify as arguments,\n     * immediately one after the other, and then emits a complete notification.\n     *\n     * <span class=\"informal\">Emits the arguments you provide, then completes.\n     * </span>\n     *\n     * <img src=\"./img/of.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the arguments given, and the complete notification thereafter. It can\n     * be used for composing with other Observables, such as with {@link concat}.\n     * By default, it uses a `null` IScheduler, which means the `next`\n     * notifications are sent synchronously, although with a different IScheduler\n     * it is possible to determine when those notifications will be delivered.\n     *\n     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n     * var numbers = Rx.Observable.of(10, 20, 30);\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = numbers.concat(letters).concat(interval);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link create}\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link throw}\n     *\n     * @param {...T} values Arguments that represent `next` values to be emitted.\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable<T>} An Observable that emits each given input value.\n     * @static true\n     * @name of\n     * @owner Observable\n     */\n    ArrayObservable.of = function () {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i - 0] = arguments[_i];\n        }\n        var scheduler = array[array.length - 1];\n        if (isScheduler_1.isScheduler(scheduler)) {\n            array.pop();\n        }\n        else {\n            scheduler = null;\n        }\n        var len = array.length;\n        if (len > 1) {\n            return new ArrayObservable(array, scheduler);\n        }\n        else if (len === 1) {\n            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n        }\n        else {\n            return new EmptyObservable_1.EmptyObservable(scheduler);\n        }\n    };\n    ArrayObservable.dispatch = function (state) {\n        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n        if (index >= count) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(array[index]);\n        if (subscriber.closed) {\n            return;\n        }\n        state.index = index + 1;\n        this.schedule(state);\n    };\n    ArrayObservable.prototype._subscribe = function (subscriber) {\n        var index = 0;\n        var array = this.array;\n        var count = array.length;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                array: array, index: index, count: count, subscriber: subscriber\n            });\n        }\n        else {\n            for (var i = 0; i < count && !subscriber.closed; i++) {\n                subscriber.next(array[i]);\n            }\n            subscriber.complete();\n        }\n    };\n    return ArrayObservable;\n}(Observable_1.Observable));\nexports.ArrayObservable = ArrayObservable;\n//# sourceMappingURL=ArrayObservable.js.map\n  })();\n});","\nrequire.register(\"rxjs/observable/ConnectableObservable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subject_1 = require('../Subject');\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\n/**\n * @class ConnectableObservable<T>\n */\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n        this._refCount = 0;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this.getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype.getSubject = function () {\n        var subject = this._subject;\n        if (!subject || subject.isStopped) {\n            this._subject = this.subjectFactory();\n        }\n        return this._subject;\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var connection = this._connection;\n        if (!connection) {\n            connection = this._connection = new Subscription_1.Subscription();\n            connection.add(this.source\n                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n            if (connection.closed) {\n                this._connection = null;\n                connection = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this._connection = connection;\n            }\n        }\n        return connection;\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return this.lift(new RefCountOperator(this));\n    };\n    return ConnectableObservable;\n}(Observable_1.Observable));\nexports.ConnectableObservable = ConnectableObservable;\nexports.connectableObservableDescriptor = {\n    operator: { value: null },\n    _refCount: { value: 0, writable: true },\n    _subscribe: { value: ConnectableObservable.prototype._subscribe },\n    getSubject: { value: ConnectableObservable.prototype.getSubject },\n    connect: { value: ConnectableObservable.prototype.connect },\n    refCount: { value: ConnectableObservable.prototype.refCount }\n};\nvar ConnectableSubscriber = (function (_super) {\n    __extends(ConnectableSubscriber, _super);\n    function ConnectableSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    ConnectableSubscriber.prototype._error = function (err) {\n        this._unsubscribe();\n        _super.prototype._error.call(this, err);\n    };\n    ConnectableSubscriber.prototype._complete = function () {\n        this._unsubscribe();\n        _super.prototype._complete.call(this);\n    };\n    ConnectableSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (connectable) {\n            this.connectable = null;\n            var connection = connectable._connection;\n            connectable._refCount = 0;\n            connectable._subject = null;\n            connectable._connection = null;\n            if (connection) {\n                connection.unsubscribe();\n            }\n        }\n    };\n    return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber));\nvar RefCountOperator = (function () {\n    function RefCountOperator(connectable) {\n        this.connectable = connectable;\n    }\n    RefCountOperator.prototype.call = function (subscriber, source) {\n        var connectable = this.connectable;\n        connectable._refCount++;\n        var refCounter = new RefCountSubscriber(subscriber, connectable);\n        var subscription = source.subscribe(refCounter);\n        if (!refCounter.closed) {\n            refCounter.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountOperator;\n}());\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, connectable) {\n        _super.call(this, destination);\n        this.connectable = connectable;\n    }\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        if (!connectable) {\n            this.connection = null;\n            return;\n        }\n        this.connectable = null;\n        var refCount = connectable._refCount;\n        if (refCount <= 0) {\n            this.connection = null;\n            return;\n        }\n        connectable._refCount = refCount - 1;\n        if (refCount > 1) {\n            this.connection = null;\n            return;\n        }\n        ///\n        // Compare the local RefCountSubscriber's connection Subscription to the\n        // connection Subscription on the shared ConnectableObservable. In cases\n        // where the ConnectableObservable source synchronously emits values, and\n        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n        // execution continues to here before the RefCountOperator has a chance to\n        // supply the RefCountSubscriber with the shared connection Subscription.\n        // For example:\n        // ```\n        // Observable.range(0, 10)\n        //   .publish()\n        //   .refCount()\n        //   .take(5)\n        //   .subscribe();\n        // ```\n        // In order to account for this case, RefCountSubscriber should only dispose\n        // the ConnectableObservable's shared connection Subscription if the\n        // connection Subscription exists, *and* either:\n        //   a. RefCountSubscriber doesn't have a reference to the shared connection\n        //      Subscription yet, or,\n        //   b. RefCountSubscriber's connection Subscription reference is identical\n        //      to the shared connection Subscription\n        ///\n        var connection = this.connection;\n        var sharedConnection = connectable._connection;\n        this.connection = null;\n        if (sharedConnection && (!connection || sharedConnection === connection)) {\n            sharedConnection.unsubscribe();\n        }\n    };\n    return RefCountSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=ConnectableObservable.js.map\n  })();\n});","\nrequire.register(\"rxjs/observable/EmptyObservable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar EmptyObservable = (function (_super) {\n    __extends(EmptyObservable, _super);\n    function EmptyObservable(scheduler) {\n        _super.call(this);\n        this.scheduler = scheduler;\n    }\n    /**\n     * Creates an Observable that emits no items to the Observer and immediately\n     * emits a complete notification.\n     *\n     * <span class=\"informal\">Just emits 'complete', and nothing else.\n     * </span>\n     *\n     * <img src=\"./img/empty.png\" width=\"100%\">\n     *\n     * This static operator is useful for creating a simple Observable that only\n     * emits the complete notification. It can be used for composing with other\n     * Observables, such as in a {@link mergeMap}.\n     *\n     * @example <caption>Emit the number 7, then complete.</caption>\n     * var result = Rx.Observable.empty().startWith(7);\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var result = interval.mergeMap(x =>\n     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following to the console:\n     * // x is equal to the count on the interval eg(0,1,2,3,...)\n     * // x will occur every 1000ms\n     * // if x % 2 is equal to 1 print abc\n     * // if x % 2 is not equal to 1 nothing will be output\n     *\n     * @see {@link create}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n     * the emission of the complete notification.\n     * @return {Observable} An \"empty\" Observable: emits only the complete\n     * notification.\n     * @static true\n     * @name empty\n     * @owner Observable\n     */\n    EmptyObservable.create = function (scheduler) {\n        return new EmptyObservable(scheduler);\n    };\n    EmptyObservable.dispatch = function (arg) {\n        var subscriber = arg.subscriber;\n        subscriber.complete();\n    };\n    EmptyObservable.prototype._subscribe = function (subscriber) {\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n        }\n        else {\n            subscriber.complete();\n        }\n    };\n    return EmptyObservable;\n}(Observable_1.Observable));\nexports.EmptyObservable = EmptyObservable;\n//# sourceMappingURL=EmptyObservable.js.map\n  })();\n});","\nrequire.register(\"rxjs/observable/ScalarObservable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nvar ScalarObservable = (function (_super) {\n    __extends(ScalarObservable, _super);\n    function ScalarObservable(value, scheduler) {\n        _super.call(this);\n        this.value = value;\n        this.scheduler = scheduler;\n        this._isScalar = true;\n        if (scheduler) {\n            this._isScalar = false;\n        }\n    }\n    ScalarObservable.create = function (value, scheduler) {\n        return new ScalarObservable(value, scheduler);\n    };\n    ScalarObservable.dispatch = function (state) {\n        var done = state.done, value = state.value, subscriber = state.subscriber;\n        if (done) {\n            subscriber.complete();\n            return;\n        }\n        subscriber.next(value);\n        if (subscriber.closed) {\n            return;\n        }\n        state.done = true;\n        this.schedule(state);\n    };\n    ScalarObservable.prototype._subscribe = function (subscriber) {\n        var value = this.value;\n        var scheduler = this.scheduler;\n        if (scheduler) {\n            return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                done: false, value: value, subscriber: subscriber\n            });\n        }\n        else {\n            subscriber.next(value);\n            if (!subscriber.closed) {\n                subscriber.complete();\n            }\n        }\n    };\n    return ScalarObservable;\n}(Observable_1.Observable));\nexports.ScalarObservable = ScalarObservable;\n//# sourceMappingURL=ScalarObservable.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/concat.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Observable_1 = require('../Observable');\nvar isScheduler_1 = require('../util/isScheduler');\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar mergeAll_1 = require('./mergeAll');\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from every\n * given input Observable after the current Observable.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * Joins this Observable with multiple other Observables by subscribing to them\n * one at a time, starting with the source, and merging their results into the\n * output Observable. Will wait for each Observable to complete before moving\n * on to the next.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = timer.concat(sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n * @example <caption>Concatenate 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = timer1.concat(timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} other An input Observable to concatenate after the source\n * Observable. More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @method concat\n * @owner Observable\n */\nfunction concat() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));\n}\nexports.concat = concat;\n/* tslint:enable:max-line-length */\n/**\n * Creates an output Observable which sequentially emits all values from given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * <img src=\"./img/concat.png\" width=\"100%\">\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n * var timer = Rx.Observable.interval(1000).take(4);\n * var sequence = Rx.Observable.range(1, 10);\n * var result = Rx.Observable.concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n *\n *\n * @example <caption>Concatenate an array of 3 Observables</caption>\n * var timer1 = Rx.Observable.interval(1000).take(10);\n * var timer2 = Rx.Observable.interval(2000).take(6);\n * var timer3 = Rx.Observable.interval(500).take(10);\n * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n *\n *\n * @example <caption>Concatenate the same Observable to repeat it</caption>\n * const timer = Rx.Observable.interval(1000).take(2);\n *\n * Rx.Observable.concat(timer, timer) // concating the same Observable!\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('...and it is done!')\n * );\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // \"...and it is done!\" also after 4s\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n *\n * @param {ObservableInput} input1 An input Observable to concatenate with others.\n * @param {ObservableInput} input2 An input Observable to concatenate with others.\n * More than one input Observables may be given as argument.\n * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n * Observable subscription on.\n * @return {Observable} All values of each passed Observable merged into a\n * single Observable, in order, in serial fashion.\n * @static true\n * @name concat\n * @owner Observable\n */\nfunction concatStatic() {\n    var observables = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        observables[_i - 0] = arguments[_i];\n    }\n    var scheduler = null;\n    var args = observables;\n    if (isScheduler_1.isScheduler(args[observables.length - 1])) {\n        scheduler = args.pop();\n    }\n    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n        return observables[0];\n    }\n    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));\n}\nexports.concatStatic = concatStatic;\n//# sourceMappingURL=concat.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/do.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Perform a side effect for every emission on the source Observable, but return\n * an Observable that is identical to the source.\n *\n * <span class=\"informal\">Intercepts each emission on the source and runs a\n * function, but returns an output which is identical to the source.</span>\n *\n * <img src=\"./img/do.png\" width=\"100%\">\n *\n * Returns a mirrored Observable of the source Observable, but modified so that\n * the provided Observer is called to perform a side effect for every value,\n * error, and completion emitted by the source. Any errors that are thrown in\n * the aforementioned Observer or handlers are safely sent down the error path\n * of the output Observable.\n *\n * This operator is useful for debugging your Observables for the correct values\n * or performing other side effects.\n *\n * Note: this is different to a `subscribe` on the Observable. If the Observable\n * returned by `do` is not subscribed, the side effects specified by the\n * Observer will never happen. `do` therefore simply spies on existing\n * execution, it does not trigger an execution to happen like `subscribe` does.\n *\n * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks\n *   .do(ev => console.log(ev))\n *   .map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link map}\n * @see {@link subscribe}\n *\n * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n * callback for `next`.\n * @param {function} [error] Callback for errors in the source.\n * @param {function} [complete] Callback for the completion of the source.\n * @return {Observable} An Observable identical to the source, but runs the\n * specified Observer or callback(s) for each item.\n * @method do\n * @name do\n * @owner Observable\n */\nfunction _do(nextOrObserver, error, complete) {\n    return this.lift(new DoOperator(nextOrObserver, error, complete));\n}\nexports._do = _do;\nvar DoOperator = (function () {\n    function DoOperator(nextOrObserver, error, complete) {\n        this.nextOrObserver = nextOrObserver;\n        this.error = error;\n        this.complete = complete;\n    }\n    DoOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n    };\n    return DoOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar DoSubscriber = (function (_super) {\n    __extends(DoSubscriber, _super);\n    function DoSubscriber(destination, nextOrObserver, error, complete) {\n        _super.call(this, destination);\n        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n        safeSubscriber.syncErrorThrowable = true;\n        this.add(safeSubscriber);\n        this.safeSubscriber = safeSubscriber;\n    }\n    DoSubscriber.prototype._next = function (value) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.next(value);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.next(value);\n        }\n    };\n    DoSubscriber.prototype._error = function (err) {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.error(err);\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.error(err);\n        }\n    };\n    DoSubscriber.prototype._complete = function () {\n        var safeSubscriber = this.safeSubscriber;\n        safeSubscriber.complete();\n        if (safeSubscriber.syncErrorThrown) {\n            this.destination.error(safeSubscriber.syncErrorValue);\n        }\n        else {\n            this.destination.complete();\n        }\n    };\n    return DoSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=do.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/map.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nfunction map(project, thisArg) {\n    if (typeof project !== 'function') {\n        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return this.lift(new MapOperator(project, thisArg));\n}\nexports.map = map;\nvar MapOperator = (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexports.MapOperator = MapOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MapSubscriber = (function (_super) {\n    __extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        _super.call(this, destination);\n        this.project = project;\n        this.count = 0;\n        this.thisArg = thisArg || this;\n    }\n    // NOTE: This looks unoptimized, but it's actually purposefully NOT\n    // using try/catch optimizations.\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=map.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/mergeAll.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * <img src=\"./img/mergeAll.png\" width=\"100%\">\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n * var firstOrder = higherOrder.mergeAll();\n * firstOrder.subscribe(x => console.log(x));\n *\n * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n * var firstOrder = higherOrder.mergeAll(2);\n * firstOrder.subscribe(x => console.log(x));\n *\n * @see {@link combineAll}\n * @see {@link concatAll}\n * @see {@link exhaust}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switch}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return {Observable} An Observable that emits values coming from all the\n * inner Observables emitted by the source Observable.\n * @method mergeAll\n * @owner Observable\n */\nfunction mergeAll(concurrent) {\n    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n    return this.lift(new MergeAllOperator(concurrent));\n}\nexports.mergeAll = mergeAll;\nvar MergeAllOperator = (function () {\n    function MergeAllOperator(concurrent) {\n        this.concurrent = concurrent;\n    }\n    MergeAllOperator.prototype.call = function (observer, source) {\n        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));\n    };\n    return MergeAllOperator;\n}());\nexports.MergeAllOperator = MergeAllOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar MergeAllSubscriber = (function (_super) {\n    __extends(MergeAllSubscriber, _super);\n    function MergeAllSubscriber(destination, concurrent) {\n        _super.call(this, destination);\n        this.concurrent = concurrent;\n        this.hasCompleted = false;\n        this.buffer = [];\n        this.active = 0;\n    }\n    MergeAllSubscriber.prototype._next = function (observable) {\n        if (this.active < this.concurrent) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, observable));\n        }\n        else {\n            this.buffer.push(observable);\n        }\n    };\n    MergeAllSubscriber.prototype._complete = function () {\n        this.hasCompleted = true;\n        if (this.active === 0 && this.buffer.length === 0) {\n            this.destination.complete();\n        }\n    };\n    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {\n        var buffer = this.buffer;\n        this.remove(innerSub);\n        this.active--;\n        if (buffer.length > 0) {\n            this._next(buffer.shift());\n        }\n        else if (this.active === 0 && this.hasCompleted) {\n            this.destination.complete();\n        }\n    };\n    return MergeAllSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\nexports.MergeAllSubscriber = MergeAllSubscriber;\n//# sourceMappingURL=mergeAll.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/multicast.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar ConnectableObservable_1 = require('../observable/ConnectableObservable');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the results of invoking a specified selector on items\n * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n *\n * <img src=\"./img/multicast.png\" width=\"100%\">\n *\n * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n * which the source sequence's elements will be multicast to the selector function\n * or Subject to push source elements into.\n * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n * as many times as needed, without causing multiple subscriptions to the source stream.\n * Subscribers to the given source will receive all notifications of the source from the\n * time of the subscription forward.\n * @return {Observable} An Observable that emits the results of invoking the selector\n * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n * the underlying stream.\n * @method multicast\n * @owner Observable\n */\nfunction multicast(subjectOrSubjectFactory, selector) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    if (typeof selector === 'function') {\n        return this.lift(new MulticastOperator(subjectFactory, selector));\n    }\n    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);\n    connectable.source = this;\n    connectable.subjectFactory = subjectFactory;\n    return connectable;\n}\nexports.multicast = multicast;\nvar MulticastOperator = (function () {\n    function MulticastOperator(subjectFactory, selector) {\n        this.subjectFactory = subjectFactory;\n        this.selector = selector;\n    }\n    MulticastOperator.prototype.call = function (subscriber, source) {\n        var selector = this.selector;\n        var subject = this.subjectFactory();\n        var subscription = selector(subject).subscribe(subscriber);\n        subscription.add(source.subscribe(subject));\n        return subscription;\n    };\n    return MulticastOperator;\n}());\nexports.MulticastOperator = MulticastOperator;\n//# sourceMappingURL=multicast.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/publishBehavior.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar BehaviorSubject_1 = require('../BehaviorSubject');\nvar multicast_1 = require('./multicast');\n/**\n * @param value\n * @return {ConnectableObservable<T>}\n * @method publishBehavior\n * @owner Observable\n */\nfunction publishBehavior(value) {\n    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));\n}\nexports.publishBehavior = publishBehavior;\n//# sourceMappingURL=publishBehavior.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/scan.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Subscriber_1 = require('../Subscriber');\n/* tslint:enable:max-line-length */\n/**\n * Applies an accumulator function over the source Observable, and returns each\n * intermediate result, with an optional seed value.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation whenever the source emits a value.</span>\n *\n * <img src=\"./img/scan.png\" width=\"100%\">\n *\n * Combines together all values emitted on the source, using an accumulator\n * function that knows how to join a new source value into the accumulation from\n * the past. Is similar to {@link reduce}, but emits the intermediate\n * accumulations.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * @example <caption>Count the number of click events</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var ones = clicks.mapTo(1);\n * var seed = 0;\n * var count = ones.scan((acc, one) => acc + one, seed);\n * count.subscribe(x => console.log(x));\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n *\n * @param {function(acc: R, value: T, index: number): R} accumulator\n * The accumulator function called on each source value.\n * @param {T|R} [seed] The initial accumulation value.\n * @return {Observable<R>} An observable of the accumulated values.\n * @method scan\n * @owner Observable\n */\nfunction scan(accumulator, seed) {\n    var hasSeed = false;\n    // providing a seed of `undefined` *should* be valid and trigger\n    // hasSeed! so don't use `seed !== undefined` checks!\n    // For this reason, we have to check it here at the original call site\n    // otherwise inside Operator/Subscriber we won't know if `undefined`\n    // means they didn't provide anything or if they literally provided `undefined`\n    if (arguments.length >= 2) {\n        hasSeed = true;\n    }\n    return this.lift(new ScanOperator(accumulator, seed, hasSeed));\n}\nexports.scan = scan;\nvar ScanOperator = (function () {\n    function ScanOperator(accumulator, seed, hasSeed) {\n        if (hasSeed === void 0) { hasSeed = false; }\n        this.accumulator = accumulator;\n        this.seed = seed;\n        this.hasSeed = hasSeed;\n    }\n    ScanOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n    };\n    return ScanOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar ScanSubscriber = (function (_super) {\n    __extends(ScanSubscriber, _super);\n    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n        _super.call(this, destination);\n        this.accumulator = accumulator;\n        this._seed = _seed;\n        this.hasSeed = hasSeed;\n        this.index = 0;\n    }\n    Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n        get: function () {\n            return this._seed;\n        },\n        set: function (value) {\n            this.hasSeed = true;\n            this._seed = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ScanSubscriber.prototype._next = function (value) {\n        if (!this.hasSeed) {\n            this.seed = value;\n            this.destination.next(value);\n        }\n        else {\n            return this._tryNext(value);\n        }\n    };\n    ScanSubscriber.prototype._tryNext = function (value) {\n        var index = this.index++;\n        var result;\n        try {\n            result = this.accumulator(this.seed, value, index);\n        }\n        catch (err) {\n            this.destination.error(err);\n        }\n        this.seed = result;\n        this.destination.next(result);\n    };\n    return ScanSubscriber;\n}(Subscriber_1.Subscriber));\n//# sourceMappingURL=scan.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/startWith.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\nvar ScalarObservable_1 = require('../observable/ScalarObservable');\nvar EmptyObservable_1 = require('../observable/EmptyObservable');\nvar concat_1 = require('./concat');\nvar isScheduler_1 = require('../util/isScheduler');\n/* tslint:enable:max-line-length */\n/**\n * Returns an Observable that emits the items you specify as arguments before it begins to emit\n * items emitted by the source Observable.\n *\n * <img src=\"./img/startWith.png\" width=\"100%\">\n *\n * @param {...T} values - Items you want the modified Observable to emit first.\n * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n * the emissions of the `next` notifications.\n * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n * emitted by the source Observable.\n * @method startWith\n * @owner Observable\n */\nfunction startWith() {\n    var array = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        array[_i - 0] = arguments[_i];\n    }\n    var scheduler = array[array.length - 1];\n    if (isScheduler_1.isScheduler(scheduler)) {\n        array.pop();\n    }\n    else {\n        scheduler = null;\n    }\n    var len = array.length;\n    if (len === 1) {\n        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);\n    }\n    else if (len > 1) {\n        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);\n    }\n    else {\n        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);\n    }\n}\nexports.startWith = startWith;\n//# sourceMappingURL=startWith.js.map\n  })();\n});","\nrequire.register(\"rxjs/operator/switchMap.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar OuterSubscriber_1 = require('../OuterSubscriber');\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nfunction switchMap(project, resultSelector) {\n    return this.lift(new SwitchMapOperator(project, resultSelector));\n}\nexports.switchMap = switchMap;\nvar SwitchMapOperator = (function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = (function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber_1.OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n  })();\n});","\nrequire.register(\"rxjs/symbol/iterator.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar root_1 = require('../util/root');\nfunction symbolIteratorPonyfill(root) {\n    var Symbol = root.Symbol;\n    if (typeof Symbol === 'function') {\n        if (!Symbol.iterator) {\n            Symbol.iterator = Symbol('iterator polyfill');\n        }\n        return Symbol.iterator;\n    }\n    else {\n        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n        var Set_1 = root.Set;\n        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n            return '@@iterator';\n        }\n        var Map_1 = root.Map;\n        // required for compatability with es6-shim\n        if (Map_1) {\n            var keys = Object.getOwnPropertyNames(Map_1.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                    return key;\n                }\n            }\n        }\n        return '@@iterator';\n    }\n}\nexports.symbolIteratorPonyfill = symbolIteratorPonyfill;\nexports.$$iterator = symbolIteratorPonyfill(root_1.root);\n//# sourceMappingURL=iterator.js.map\n  })();\n});","\nrequire.register(\"rxjs/symbol/observable.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar root_1 = require('../util/root');\nfunction getSymbolObservable(context) {\n    var $$observable;\n    var Symbol = context.Symbol;\n    if (typeof Symbol === 'function') {\n        if (Symbol.observable) {\n            $$observable = Symbol.observable;\n        }\n        else {\n            $$observable = Symbol('observable');\n            Symbol.observable = $$observable;\n        }\n    }\n    else {\n        $$observable = '@@observable';\n    }\n    return $$observable;\n}\nexports.getSymbolObservable = getSymbolObservable;\nexports.$$observable = getSymbolObservable(root_1.root);\n//# sourceMappingURL=observable.js.map\n  })();\n});","\nrequire.register(\"rxjs/symbol/rxSubscriber.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar root_1 = require('../util/root');\nvar Symbol = root_1.root.Symbol;\nexports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n    Symbol.for('rxSubscriber') : '@@rxSubscriber';\n//# sourceMappingURL=rxSubscriber.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/ObjectUnsubscribedError.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nvar ObjectUnsubscribedError = (function (_super) {\n    __extends(ObjectUnsubscribedError, _super);\n    function ObjectUnsubscribedError() {\n        var err = _super.call(this, 'object unsubscribed');\n        this.name = err.name = 'ObjectUnsubscribedError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return ObjectUnsubscribedError;\n}(Error));\nexports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/UnsubscriptionError.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nvar UnsubscriptionError = (function (_super) {\n    __extends(UnsubscriptionError, _super);\n    function UnsubscriptionError(errors) {\n        _super.call(this);\n        this.errors = errors;\n        var err = Error.call(this, errors ?\n            errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return ((i + 1) + \") \" + err.toString()); }).join('\\n  ') : '');\n        this.name = err.name = 'UnsubscriptionError';\n        this.stack = err.stack;\n        this.message = err.message;\n    }\n    return UnsubscriptionError;\n}(Error));\nexports.UnsubscriptionError = UnsubscriptionError;\n//# sourceMappingURL=UnsubscriptionError.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/errorObject.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\n// typeof any so that it we don't have to cast when comparing a result to the error object\nexports.errorObject = { e: {} };\n//# sourceMappingURL=errorObject.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isArray.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nexports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isArrayLike.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nexports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArrayLike.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isFunction.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nfunction isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isObject.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isPromise.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nfunction isPromise(value) {\n    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\nexports.isPromise = isPromise;\n//# sourceMappingURL=isPromise.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/isScheduler.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nfunction isScheduler(value) {\n    return value && typeof value.schedule === 'function';\n}\nexports.isScheduler = isScheduler;\n//# sourceMappingURL=isScheduler.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/root.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\n/**\n * window: browser in DOM main thread\n * self: browser in WebWorker\n * global: Node.js/other\n */\nexports.root = (typeof window == 'object' && window.window === window && window\n    || typeof self == 'object' && self.self === self && self\n    || typeof global == 'object' && global.global === global && global);\nif (!exports.root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n}\n//# sourceMappingURL=root.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/subscribeToResult.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar root_1 = require('./root');\nvar isArrayLike_1 = require('./isArrayLike');\nvar isPromise_1 = require('./isPromise');\nvar isObject_1 = require('./isObject');\nvar Observable_1 = require('../Observable');\nvar iterator_1 = require('../symbol/iterator');\nvar InnerSubscriber_1 = require('../InnerSubscriber');\nvar observable_1 = require('../symbol/observable');\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n    if (destination.closed) {\n        return null;\n    }\n    if (result instanceof Observable_1.Observable) {\n        if (result._isScalar) {\n            destination.next(result.value);\n            destination.complete();\n            return null;\n        }\n        else {\n            return result.subscribe(destination);\n        }\n    }\n    else if (isArrayLike_1.isArrayLike(result)) {\n        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n            destination.next(result[i]);\n        }\n        if (!destination.closed) {\n            destination.complete();\n        }\n    }\n    else if (isPromise_1.isPromise(result)) {\n        result.then(function (value) {\n            if (!destination.closed) {\n                destination.next(value);\n                destination.complete();\n            }\n        }, function (err) { return destination.error(err); })\n            .then(null, function (err) {\n            // Escaping the Promise trap: globally throw unhandled errors\n            root_1.root.setTimeout(function () { throw err; });\n        });\n        return destination;\n    }\n    else if (result && typeof result[iterator_1.$$iterator] === 'function') {\n        var iterator = result[iterator_1.$$iterator]();\n        do {\n            var item = iterator.next();\n            if (item.done) {\n                destination.complete();\n                break;\n            }\n            destination.next(item.value);\n            if (destination.closed) {\n                break;\n            }\n        } while (true);\n    }\n    else if (result && typeof result[observable_1.$$observable] === 'function') {\n        var obs = result[observable_1.$$observable]();\n        if (typeof obs.subscribe !== 'function') {\n            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n        }\n        else {\n            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n        }\n    }\n    else {\n        var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n        var msg = (\"You provided \" + value + \" where a stream was expected.\")\n            + ' You can provide an Observable, Promise, Array, or Iterable.';\n        destination.error(new TypeError(msg));\n    }\n    return null;\n}\nexports.subscribeToResult = subscribeToResult;\n//# sourceMappingURL=subscribeToResult.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/toSubscriber.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nvar Observer_1 = require('../Observer');\nfunction toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {\n            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber_1.Subscriber(Observer_1.empty);\n    }\n    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n  })();\n});","\nrequire.register(\"rxjs/util/tryCatch.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"rxjs\");\n  (function() {\n    \"use strict\";\nvar errorObject_1 = require('./errorObject');\nvar tryCatchTarget;\nfunction tryCatcher() {\n    try {\n        return tryCatchTarget.apply(this, arguments);\n    }\n    catch (e) {\n        errorObject_1.errorObject.e = e;\n        return errorObject_1.errorObject;\n    }\n}\nfunction tryCatch(fn) {\n    tryCatchTarget = fn;\n    return tryCatcher;\n}\nexports.tryCatch = tryCatch;\n;\n//# sourceMappingURL=tryCatch.js.map\n  })();\n});","\nrequire.register(\"search-params/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"search-params\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Split path\nvar getPath = exports.getPath = function getPath(path) {\n    return path.split('?')[0];\n};\nvar getSearch = exports.getSearch = function getSearch(path) {\n    return path.split('?')[1];\n};\n\n// Search param value\nvar isSerialisable = function isSerialisable(val) {\n    return val !== undefined && val !== null && val !== '';\n};\n\n// Search param name\nvar bracketTest = /\\[\\]$/;\nvar hasBrackets = exports.hasBrackets = function hasBrackets(paramName) {\n    return bracketTest.test(paramName);\n};\nvar withoutBrackets = exports.withoutBrackets = function withoutBrackets(paramName) {\n    return paramName.replace(bracketTest, '');\n};\n\n/**\n * Parse a querystring and return a list of params (Objects with name and value properties)\n * @param  {String} querystring The querystring to parse\n * @return {Array[Object]}      The list of params\n */\nvar parse = exports.parse = function parse(querystring) {\n    return querystring.split('&').reduce(function (params, param) {\n        var split = param.split('=');\n        var name = split[0];\n        var value = split[1];\n\n        return params.concat(split.length === 1 ? { name: name, value: true } : { name: name, value: decodeURIComponent(value) });\n    }, []);\n};\n\n/**\n * Reduce a list of parameters (returned by `.parse()``) to an object (key-value pairs)\n * @param  {Array} paramList The list of parameters returned by `.parse()`\n * @return {Object}          The object of parameters (key-value pairs)\n */\nvar toObject = exports.toObject = function toObject(paramList) {\n    return paramList.reduce(function (params, _ref) {\n        var name = _ref.name;\n        var value = _ref.value;\n\n        var isArray = hasBrackets(name);\n        var currentValue = params[withoutBrackets(name)];\n\n        if (currentValue === undefined) {\n            params[withoutBrackets(name)] = isArray ? [value] : value;\n        } else {\n            params[withoutBrackets(name)] = [].concat(currentValue, value);\n        }\n\n        return params;\n    }, {});\n};\n\n/**\n * Build a querystring from a list of parameters\n * @param  {Array} paramList The list of parameters (see `.parse()`)\n * @return {String}          The querystring\n */\nvar build = exports.build = function build(paramList) {\n    return paramList.filter(function (_ref2) {\n        var value = _ref2.value;\n        return value !== undefined && value !== null;\n    }).map(function (_ref3) {\n        var name = _ref3.name;\n        var value = _ref3.value;\n        return value === true ? name : name + '=' + encodeURIComponent(value);\n    }).join('&');\n};\n\n/**\n * Remove a list of parameters from a querystring\n * @param  {String} querystring  The original querystring\n * @param  {Array}  paramsToOmit The parameters to omit\n * @return {String}              The querystring\n */\nvar omit = exports.omit = function omit(querystring, paramsToOmit) {\n    if (!querystring) return '';\n\n    var remainingQueryParams = parse(querystring).filter(function (_ref4) {\n        var name = _ref4.name;\n        return paramsToOmit.indexOf(withoutBrackets(name)) === -1;\n    });\n    var remainingQueryString = build(remainingQueryParams);\n\n    return remainingQueryString || '';\n};\n  })();\n});","'use strict';\n\n/* jshint ignore:start */\n(function () {\n  var WebSocket = window.WebSocket || window.MozWebSocket;\n  var br = window.brunch = window.brunch || {};\n  var ar = br['auto-reload'] = br['auto-reload'] || {};\n  if (!WebSocket || ar.disabled) return;\n  if (window._ar) return;\n  window._ar = true;\n\n  var cacheBuster = function cacheBuster(url) {\n    var date = Math.round(Date.now() / 1000).toString();\n    url = url.replace(/(\\&|\\\\?)cacheBuster=\\d*/, '');\n    return url + (url.indexOf('?') >= 0 ? '&' : '?') + 'cacheBuster=' + date;\n  };\n\n  var browser = navigator.userAgent.toLowerCase();\n  var forceRepaint = ar.forceRepaint || browser.indexOf('chrome') > -1;\n\n  var reloaders = {\n    page: function page() {\n      window.location.reload(true);\n    },\n\n    stylesheet: function stylesheet() {\n      [].slice.call(document.querySelectorAll('link[rel=stylesheet]')).filter(function (link) {\n        var val = link.getAttribute('data-autoreload');\n        return link.href && val != 'false';\n      }).forEach(function (link) {\n        link.href = cacheBuster(link.href);\n      });\n\n      // Hack to force page repaint after 25ms.\n      if (forceRepaint) setTimeout(function () {\n        document.body.offsetHeight;\n      }, 25);\n    },\n\n    javascript: function javascript() {\n      var scripts = [].slice.call(document.querySelectorAll('script'));\n      var textScripts = scripts.map(function (script) {\n        return script.text;\n      }).filter(function (text) {\n        return text.length > 0;\n      });\n      var srcScripts = scripts.filter(function (script) {\n        return script.src;\n      });\n\n      var loaded = 0;\n      var all = srcScripts.length;\n      var onLoad = function onLoad() {\n        loaded = loaded + 1;\n        if (loaded === all) {\n          textScripts.forEach(function (script) {\n            eval(script);\n          });\n        }\n      };\n\n      srcScripts.forEach(function (script) {\n        var src = script.src;\n        script.remove();\n        var newScript = document.createElement('script');\n        newScript.src = cacheBuster(src);\n        newScript.async = true;\n        newScript.onload = onLoad;\n        document.head.appendChild(newScript);\n      });\n    }\n  };\n  var port = ar.port || 9485;\n  var host = br.server || window.location.hostname || 'localhost';\n\n  var connect = function connect() {\n    var connection = new WebSocket('ws://' + host + ':' + port);\n    connection.onmessage = function (event) {\n      if (ar.disabled) return;\n      var message = event.data;\n      var reloader = reloaders[message] || reloaders.page;\n      reloader();\n    };\n    connection.onerror = function () {\n      if (connection.readyState) connection.close();\n    };\n    connection.onclose = function () {\n      window.setTimeout(connect, 1000);\n    };\n  };\n  connect();\n})();\n/* jshint ignore:end */\n"]}